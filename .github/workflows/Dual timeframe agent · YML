name: Dual Timeframe Options Agent

on:
  schedule:
    - cron: '35 14 * * 1-5'  # 9:35 AM ET
    - cron: '05 21 * * 1-5'  # 4:05 PM ET
  workflow_dispatch:

jobs:
  run-agent:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pandas numpy requests

      - name: Run Dual Timeframe Agent
        env:
          TIINGO_API_KEY: ${{ secrets.TIINGO_API_KEY }}
        run: |
          python << 'EOF'
          import pandas as pd
          import numpy as np
          import requests
          import json
          import os
          from datetime import datetime, timedelta

          TIINGO_API_KEY = os.environ.get('TIINGO_API_KEY', '14febdd1820f1a4aa11e1bf920cd3a38950b77a5')
          
          SYMBOLS = ['SPY', 'QQQ', 'IWM', 'DIA', 'XLK', 'XLF', 'XLV', 'XLE', 'XLI', 'XLP', 'XLY', 'XLU', 'XLRE', 'XLB']
          
          # Dual Timeframe Parameters
          INTRADAY_PARAMS = {
              'fast_sma': 5,
              'slow_sma': 20,
              'atr_period': 10,
              'stop_atr': 0.75,
              'target1_atr': 1.0,
              'target2_atr': 1.5
          }
          
          SWING_PARAMS = {
              'fast_sma': 10,
              'slow_sma': 30,
              'atr_period': 14,
              'stop_atr': 1.5,
              'target1_atr': 2.0,
              'target2_atr': 3.0
          }

          os.makedirs('data', exist_ok=True)

          def fetch_tiingo_data(symbol, days=400):
              end_date = datetime.now()
              start_date = end_date - timedelta(days=days)
              url = f"https://api.tiingo.com/tiingo/daily/{symbol}/prices"
              params = {
                  'startDate': start_date.strftime('%Y-%m-%d'),
                  'endDate': end_date.strftime('%Y-%m-%d'),
                  'token': TIINGO_API_KEY
              }
              try:
                  r = requests.get(url, params=params, timeout=30)
                  if r.status_code == 200:
                      data = r.json()
                      if data:
                          df = pd.DataFrame(data)
                          df['Date'] = pd.to_datetime(df['date']).dt.strftime('%Y-%m-%dT%H:%M:%SZ')
                          df = df.rename(columns={
                              'open': 'Open', 'high': 'High', 'low': 'Low',
                              'close': 'Close', 'volume': 'Volume'
                          })
                          return df[['Date', 'Open', 'High', 'Low', 'Close', 'Volume']]
              except Exception as e:
                  print(f"Error fetching {symbol}: {e}")
              return None

          def calculate_indicators(df, params):
              """Calculate indicators with given parameters"""
              df = df.copy()
              
              # ATR
              df['H-L'] = df['High'] - df['Low']
              df['H-PC'] = abs(df['High'] - df['Close'].shift(1))
              df['L-PC'] = abs(df['Low'] - df['Close'].shift(1))
              df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)
              df['ATR'] = df['TR'].rolling(window=params['atr_period']).mean()
              
              # SMAs
              df['FastSMA'] = df['Close'].rolling(window=params['fast_sma']).mean()
              df['SlowSMA'] = df['Close'].rolling(window=params['slow_sma']).mean()
              
              # Bias
              df['Bias'] = 'HOLD'
              df.loc[df['FastSMA'] > df['SlowSMA'], 'Bias'] = 'CALL'
              df.loc[df['FastSMA'] < df['SlowSMA'], 'Bias'] = 'PUT'
              
              return df

          def calculate_fibonacci(df):
              """Calculate Fibonacci levels from recent swing high/low"""
              recent = df.tail(60)
              swing_high = float(recent['High'].max())
              swing_low = float(recent['Low'].min())
              fib_range = swing_high - swing_low
              
              return {
                  'swing_high': swing_high,
                  'swing_low': swing_low,
                  'R1': swing_high,
                  'R2': swing_low + (fib_range * 1.272),
                  'R3': swing_low + (fib_range * 1.618),
                  'S1': swing_high - (fib_range * 0.382),
                  'S2': swing_high - (fib_range * 0.500),
                  'S3': swing_high - (fib_range * 0.618)
              }

          def calculate_bar_counts(df):
              """Calculate consecutive bar counts for each agent"""
              counts = {'base': 0, 'gann': 0, 'dqn': 0, 'wave': 0}
              
              for i in range(len(df) - 20, len(df)):
                  if i < 0:
                      continue
                  row = df.iloc[i]
                  is_bullish = float(row['Close']) >= float(row['Open'])
                  
                  for agent in counts:
                      if is_bullish:
                          counts[agent] = counts[agent] + 1 if counts[agent] >= 0 else 1
                      else:
                          counts[agent] = counts[agent] - 1 if counts[agent] <= 0 else -1
              
              return counts

          def generate_signal(df, params, mode):
              """Generate trading signal for given timeframe"""
              if df is None or len(df) < 50:
                  return None
              
              df = calculate_indicators(df, params)
              latest = df.iloc[-1]
              
              price = float(latest['Close'])
              atr = float(latest['ATR']) if pd.notna(latest['ATR']) else 5.0
              bias = str(latest['Bias'])
              
              # Calculate stops and targets based on direction
              if bias == 'CALL':
                  stop = price - (atr * params['stop_atr'])
                  target1 = price + (atr * params['target1_atr'])
                  target2 = price + (atr * params['target2_atr'])
              elif bias == 'PUT':
                  stop = price + (atr * params['stop_atr'])
                  target1 = price - (atr * params['target1_atr'])
                  target2 = price - (atr * params['target2_atr'])
              else:
                  stop = price - (atr * params['stop_atr'])
                  target1 = price + (atr * params['target1_atr'])
                  target2 = price + (atr * params['target2_atr'])
              
              # Calculate confidence based on trend strength
              fast_sma = float(latest['FastSMA']) if pd.notna(latest['FastSMA']) else price
              slow_sma = float(latest['SlowSMA']) if pd.notna(latest['SlowSMA']) else price
              trend_strength = abs(fast_sma - slow_sma) / price * 100
              confidence = min(85, 50 + trend_strength * 10)
              
              return {
                  'signal': bias,
                  'confidence': round(confidence, 1),
                  'entry': round(price, 2),
                  'stop': round(stop, 2),
                  'target1': round(target1, 2),
                  'target2': round(target2, 2),
                  'atr': round(atr, 2)
              }

          def generate_pnf_data(df, box_size=5, reversal=3):
              """Generate Point & Figure chart data"""
              prices = df['Close'].tail(100).tolist()
              columns = []
              current_col = {'type': 'X', 'boxes': []}
              last_price = round(float(prices[0]) / box_size) * box_size
              current_col['boxes'].append(last_price)
              
              for price in prices[1:]:
                  price = float(price)
                  box_price = round(price / box_size) * box_size
                  
                  if current_col['type'] == 'X':
                      if box_price > last_price:
                          for p in range(int(last_price + box_size), int(box_price + box_size), int(box_size)):
                              current_col['boxes'].append(p)
                          last_price = box_price
                      elif box_price <= last_price - (reversal * box_size):
                          columns.append(current_col.copy())
                          current_col = {'type': 'O', 'boxes': []}
                          for p in range(int(last_price - box_size), int(box_price - box_size), -int(box_size)):
                              current_col['boxes'].append(p)
                          last_price = box_price
                  else:
                      if box_price < last_price:
                          for p in range(int(last_price - box_size), int(box_price - box_size), -int(box_size)):
                              current_col['boxes'].append(p)
                          last_price = box_price
                      elif box_price >= last_price + (reversal * box_size):
                          columns.append(current_col.copy())
                          current_col = {'type': 'X', 'boxes': []}
                          for p in range(int(last_price + box_size), int(box_price + box_size), int(box_size)):
                              current_col['boxes'].append(p)
                          last_price = box_price
              
              columns.append(current_col)
              
              return {
                  'columns': len(columns),
                  'current_type': columns[-1]['type'] if columns else 'X',
                  'signal': 'BULLISH' if columns and columns[-1]['type'] == 'X' else 'BEARISH',
                  'last_price': last_price
              }

          # Process each symbol
          all_signals = {}
          sector_data = []
          
          for symbol in SYMBOLS:
              print(f"Processing {symbol}...")
              df = fetch_tiingo_data(symbol)
              
              if df is not None and len(df) > 50:
                  # Calculate both timeframe signals
                  intraday_signal = generate_signal(df, INTRADAY_PARAMS, 'intraday')
                  swing_signal = generate_signal(df, SWING_PARAMS, 'swing')
                  
                  # Calculate Fibonacci levels
                  fib_levels = calculate_fibonacci(df)
                  
                  # Calculate bar counts
                  bar_counts = calculate_bar_counts(df)
                  
                  # Generate P&F data
                  pnf_data = generate_pnf_data(df)
                  
                  # Add additional columns for swing analysis
                  df_swing = calculate_indicators(df, SWING_PARAMS)
                  
                  # Gann/Elliott indicators (simplified)
                  df_swing['GeoLevel'] = df_swing['Close'] * 1.0
                  df_swing['PhiLevel'] = df_swing['Close'] * 1.618 / 1.618
                  
                  # Price Confluence (agent agreement)
                  price = float(df_swing.iloc[-1]['Close'])
                  fast = float(df_swing.iloc[-1]['FastSMA']) if pd.notna(df_swing.iloc[-1]['FastSMA']) else price
                  slow = float(df_swing.iloc[-1]['SlowSMA']) if pd.notna(df_swing.iloc[-1]['SlowSMA']) else price
                  
                  base_vote = 1 if fast > slow else -1
                  gann_vote = 1 if price > slow else -1
                  dqn_vote = 1 if bar_counts['dqn'] > 0 else (-1 if bar_counts['dqn'] < 0 else 0)
                  wave_vote = 1 if bar_counts['wave'] > 2 else (-1 if bar_counts['wave'] < -2 else 0)
                  
                  total_votes = base_vote + gann_vote + dqn_vote + wave_vote
                  df_swing['PriceConfluence'] = int(abs(total_votes))
                  df_swing['TimeConfluence'] = int(1 if pnf_data['signal'] == 'BULLISH' else 0)
                  
                  # Clean up columns
                  df_final = df_swing[['Date', 'Open', 'High', 'Low', 'Close', 'Volume', 'ATR', 
                                       'FastSMA', 'SlowSMA', 'Bias', 'GeoLevel', 'PhiLevel',
                                       'PriceConfluence', 'TimeConfluence']].copy()
                  
                  # Ensure all numeric columns are proper floats
                  for col in ['Open', 'High', 'Low', 'Close', 'Volume', 'ATR', 'FastSMA', 'SlowSMA', 'GeoLevel', 'PhiLevel']:
                      df_final[col] = pd.to_numeric(df_final[col], errors='coerce').round(2)
                  
                  df_final.to_csv(f'data/{symbol}.csv', index=False)
                  print(f"  Saved {len(df_final)} rows for {symbol}")
                  
                  # Store signals
                  all_signals[symbol] = {
                      'intraday': intraday_signal,
                      'swing': swing_signal,
                      'fibonacci': fib_levels,
                      'bar_counts': bar_counts,
                      'pnf': pnf_data,
                      'price': round(price, 2),
                      'change_pct': round((price - float(df_swing.iloc[-2]['Close'])) / float(df_swing.iloc[-2]['Close']) * 100, 2) if len(df_swing) > 1 else 0
                  }
                  
                  # Sector data for rotation analysis
                  if symbol not in ['SPY', 'QQQ', 'IWM', 'DIA']:
                      month_ago_idx = max(0, len(df_swing) - 21)
                      month_ago_price = float(df_swing.iloc[month_ago_idx]['Close'])
                      perf_1m = (price - month_ago_price) / month_ago_price * 100
                      
                      sector_data.append({
                          'symbol': symbol,
                          'price': round(price, 2),
                          'perf_1m': round(perf_1m, 2),
                          'signal': swing_signal['signal'] if swing_signal else 'HOLD'
                      })
              else:
                  print(f"  No data for {symbol}")

          # Save dual signals JSON
          with open('data/dual_signals.json', 'w') as f:
              json.dump(all_signals, f, indent=2)
          print("Saved dual_signals.json")

          # Save sector rotation data
          sector_data.sort(key=lambda x: x['perf_1m'], reverse=True)
          with open('data/sector_rotation.json', 'w') as f:
              json.dump(sector_data, f, indent=2)
          print("Saved sector_rotation.json")

          # Generate health/status JSON
          spy_data = all_signals.get('SPY', {})
          status = {
              'timestamp': datetime.now().strftime('%Y-%m-%dT%H:%M:%SZ'),
              'status': 'online',
              'symbols_processed': len(all_signals),
              'spy_price': spy_data.get('price', 0),
              'spy_intraday_signal': spy_data.get('intraday', {}).get('signal', 'HOLD'),
              'spy_swing_signal': spy_data.get('swing', {}).get('signal', 'HOLD'),
              'trade_allowed': True
          }
          
          with open('data/status.json', 'w') as f:
              json.dump(status, f, indent=2)
          print("Saved status.json")

          print(f"\nCompleted processing {len(all_signals)} symbols")
          EOF

      - name: Commit and push
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add -A
          git diff --staged --quiet || git commit -m "Update dual timeframe signals $(date -u +'%Y-%m-%d %H:%M UTC')"
          git push
