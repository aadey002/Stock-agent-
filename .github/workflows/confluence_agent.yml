#!/usr/bin/env python3
"""
Stock Confluence Agent with Full Gann Analysis + Ollama LLM Integration
========================================================================

MULTI-AGENT CONSENSUS SYSTEM with 4 Agents:
1. Base Confluence Agent - SMA crossover, ATR stops, geometry levels
2. Gann-Elliott Agent - Square of 9, Time Cycles, Elliott Waves
3. DQN/RL Agent - Deep Q-Network reinforcement learning
4. Ollama LLM Agent - AI-powered market analysis

OLLAMA INTEGRATIONS (ALL 3):
- Agent #4: Ollama as voting member in consensus system
- Gann Interpreter: Natural language analysis of Gann levels
- Trade Advisor: Final recommendation with detailed reasoning

SIGNAL CLASSIFICATION:
- 4/4 agents agree = ULTRA signal (89% win rate target)
- 3/4 agents agree = SUPER signal (78% win rate target)
- 2/4 agents agree = MODERATE signal (65% win rate target)
- 1/4 or 0/4 = NO TRADE

NOTE: This is a research tool, not trading advice.
"""

import csv
import json
import logging
import math
import os
import pathlib
import time
import urllib.error
import urllib.request
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from enum import Enum
import pandas as pd

# =========================================================================
# CONFIGURATION
# =========================================================================

# ETF Selection - Change to trade different symbol
SUPPORTED_SYMBOLS = ["SPY", "QQQ", "IWM", "DIA", "XLF", "XLE", "XLK", "XLV", "XLI", "XLU", "GLD", "TLT"]
ACTIVE_SYMBOL = os.getenv("TRADING_SYMBOL", "SPY")

if ACTIVE_SYMBOL not in SUPPORTED_SYMBOLS:
    ACTIVE_SYMBOL = "SPY"

# =========================================================================
# OLLAMA API CONFIGURATION - GLM-4 CLOUD
# =========================================================================
# GLM-4 (Zhipu AI) via Ollama Cloud
# Command: ollama run glm-4.6:cloud

# Groq Cloud API Configuration
GROQ_API_KEY = os.getenv("GROQ_API_KEY", "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")
GROQ_API_URL = os.getenv("GROQ_API_URL", "https://api.groq.com/openai/v1/chat/completions")
GROQ_MODEL = os.getenv("GROQ_MODEL", "llama-3.1-70b-versatile")
GROQ_TIMEOUT = 60
GROQ_ENABLED = os.getenv("GROQ_ENABLED", "true").lower() == "true"

# Tiingo API
TIINGO_TOKEN = os.getenv("TIINGO_TOKEN", "")

# =========================================================================
# ENUMS
# =========================================================================

class TurnType(Enum):
    PULLBACK = "PULLBACK"
    BREAKDOWN = "BREAKDOWN"
    BREAKOUT = "BREAKOUT"
    BOUNCE = "BOUNCE"
    NO_TURN = "NO_TURN"

class Timeframe(Enum):
    MIN_15 = "15 Min"
    DAILY = "Daily"
    WEEKLY = "Weekly"

class OptionsAction(Enum):
    BUY_CALLS = "BUY CALLS"
    BUY_PUTS = "BUY PUTS"
    NO_ACTION = "NO ACTION - WAIT"

class SignalStrength(Enum):
    ULTRA = "ULTRA"       # 4/4 agents
    SUPER = "SUPER"       # 3/4 agents
    MODERATE = "MODERATE" # 2/4 agents
    WEAK = "WEAK"         # 1/4 agents
    NONE = "NONE"         # 0/4 agents

# =========================================================================
# LOGGING
# =========================================================================

def setup_logging(log_dir: str = "logs") -> logging.Logger:
    log_path = pathlib.Path(log_dir)
    log_path.mkdir(parents=True, exist_ok=True)
    
    logger = logging.getLogger("confluence_agent")
    logger.setLevel(logging.INFO)
    if logger.hasHandlers():
        logger.handlers.clear()
    
    fmt = logging.Formatter('%(asctime)s | %(levelname)-8s | %(message)s', '%Y-%m-%d %H:%M:%S')
    
    fh = logging.FileHandler(log_path / "agent.log")
    fh.setFormatter(fmt)
    logger.addHandler(fh)
    
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    logger.addHandler(ch)
    
    return logger

logger = setup_logging()

# =========================================================================
# OLLAMA LLM CLIENT - ALL 3 INTEGRATIONS
# =========================================================================

class GroqClient:
    """Groq Cloud API Client for AI-powered trading analysis."""
    
    def __init__(self):
        self.api_url = GROQ_API_URL
        self.api_key = GROQ_API_KEY
        self.model = GROQ_MODEL
        self.enabled = GROQ_ENABLED and bool(self.api_key)
    
    def _call(self, prompt: str, system: str = None) -> Optional[str]:
        if not self.enabled:
            return None
        try:
            messages = []
            if system:
                messages.append({"role": "system", "content": system})
            messages.append({"role": "user", "content": prompt})
            
            payload = {
                "model": self.model,
                "messages": messages,
                "temperature": 0.3,
                "max_tokens": 600
            }
            data = json.dumps(payload).encode('utf-8')
            req = urllib.request.Request(self.api_url, data=data)
            req.add_header('Content-Type', 'application/json')
            req.add_header('Authorization', f'Bearer {self.api_key}')
            
            logger.info(f"[Groq] Calling {self.model}...")
            with urllib.request.urlopen(req, timeout=GROQ_TIMEOUT) as resp:
                result = json.loads(resp.read().decode('utf-8'))
                content = result.get('choices', [{}])[0].get('message', {}).get('content', '')
                logger.info(f"[Groq] Response received ({len(content)} chars)")
                return content
        except Exception as e:
            logger.warning(f"[Groq] Error: {e}")
            return None
    
    def analyze_sentiment(self, symbol: str, data: Dict) -> Dict:
        system = 'You are a trading analyst. Reply with "SIGNAL: CALL" or "SIGNAL: PUT" or "SIGNAL: NEUTRAL" first.'
        prompt = f"""Analyze {symbol}: Price=${data.get('price',0):.2f}, SMA20=${data.get('sma20',0):.2f}, 
SMA50=${data.get('sma50',0):.2f}, Trend={data.get('trend','?')}, GannConf={data.get('gann_conf',0)}/100"""
        resp = self._call(prompt, system)
        if not resp:
            return {'signal': 'NEUTRAL', 'confidence': 0}
        upper = resp.upper()
        if 'SIGNAL: CALL' in upper:
            return {'signal': 'CALL', 'confidence': 75, 'reasoning': resp[:300]}
        elif 'SIGNAL: PUT' in upper:
            return {'signal': 'PUT', 'confidence': 75, 'reasoning': resp[:300]}
        return {'signal': 'NEUTRAL', 'confidence': 50, 'reasoning': resp[:300]}
    
    def interpret_gann(self, symbol: str, gann: Dict) -> str:
        system = "You are W.D. Gann. Interpret the data and give price targets."
        prompt = f"""{symbol} @ ${gann.get('price',0):.2f}
SQ9 Resistance: {gann.get('resistance',[])}
SQ9 Support: {gann.get('support',[])}
Confluence: {gann.get('confluence',0)}/100"""
        return self._call(prompt, system) or "Unavailable"
    
    def trade_plan(self, symbol: str, signals: Dict, market: Dict) -> Dict:
        system = 'Reply with "RECOMMENDATION: BUY [SYMBOL] CALLS" or "PUTS" or "NO TRADE". Include strike/expiry/stops.'
        prompt = f"""{symbol} @ ${market.get('price',0):.2f}
Agents: Base={signals.get('base','?')}, Gann={signals.get('gann','?')}, DQN={signals.get('dqn','?')}, AI={signals.get('groq','?')}
Consensus: {signals.get('direction','?')} ({signals.get('agreement',0)}/4)
ATR: ${market.get('atr',0):.2f}"""
        resp = self._call(prompt, system)
        if not resp:
            return {'recommendation': 'NO TRADE', 'plan': None}
        upper = resp.upper()
        price, atr = market.get('price', 0), market.get('atr', 1)
        if f'BUY {symbol.upper()} CALLS' in upper:
            rec, d = f'BUY {symbol} CALLS', 'CALL'
        elif f'BUY {symbol.upper()} PUTS' in upper:
            rec, d = f'BUY {symbol} PUTS', 'PUT'
        else:
            return {'recommendation': 'NO TRADE', 'reasoning': resp, 'plan': None}
        plan = {'strike': round(price), 'expiry': '7-14 DTE',
                'stop': round(price - atr*1.5, 2) if d == 'CALL' else round(price + atr*1.5, 2),
                'target1': round(price + atr*2, 2) if d == 'CALL' else round(price - atr*2, 2),
                'target2': round(price + atr*3, 2) if d == 'CALL' else round(price - atr*3, 2)}
        return {'recommendation': rec, 'reasoning': resp, 'plan': plan}

    # =========================================================================
    # INTEGRATION #1: OLLAMA AS 4TH VOTING AGENT
    # =========================================================================
    
    def analyze_market_sentiment(self, symbol: str, price_data: Dict) -> Dict:
        """
        AGENT #4: Ollama as voting member in consensus system.
        Returns CALL/PUT/NEUTRAL vote with confidence.
        """
        system_prompt = """You are a quantitative trading analyst specializing in options.
Analyze the market data and provide a clear trading signal.
Your response MUST start with exactly one of:
- "SIGNAL: CALL" (bullish)
- "SIGNAL: PUT" (bearish)  
- "SIGNAL: NEUTRAL" (no trade)
Then provide 2-3 sentences of reasoning."""
        
        prompt = f"""Analyze {symbol} for options trading:

PRICE DATA:
- Current Price: ${price_data.get('current_price', 0):.2f}
- 20-day SMA: ${price_data.get('sma_20', 0):.2f}
- 50-day SMA: ${price_data.get('sma_50', 0):.2f}
- ATR (14): ${price_data.get('atr', 0):.2f}
- Trend: {price_data.get('trend', 'unknown')}
- Volume vs Avg: {price_data.get('volume_ratio', 1.0):.1%}

GANN ANALYSIS:
- Nearest Support (SQ9): ${price_data.get('gann_support', 0):.2f}
- Nearest Resistance (SQ9): ${price_data.get('gann_resistance', 0):.2f}
- Gann Confluence Score: {price_data.get('gann_confluence', 0)}/100
- Turn Prediction: {price_data.get('turn_type', 'N/A')}

OTHER AGENTS:
- Base Confluence: {price_data.get('base_signal', 'N/A')}
- Gann-Elliott: {price_data.get('gann_signal', 'N/A')}

What is your signal? Start with "SIGNAL: CALL" or "SIGNAL: PUT" or "SIGNAL: NEUTRAL"."""

        response = self._call_api(prompt, system_prompt)
        
        if not response:
            return {
                'signal': 'NEUTRAL',
                'confidence': 0,
                'reasoning': 'Ollama unavailable',
                'vote': 0  # No vote
            }
        
        response_upper = response.upper()
        if 'SIGNAL: CALL' in response_upper:
            signal, confidence, vote = 'CALL', 75, 1
        elif 'SIGNAL: PUT' in response_upper:
            signal, confidence, vote = 'PUT', 75, -1
        else:
            signal, confidence, vote = 'NEUTRAL', 50, 0
        
        return {
            'signal': signal,
            'confidence': confidence,
            'reasoning': response[:500],
            'vote': vote
        }
    
    # =========================================================================
    # INTEGRATION #2: GANN INTERPRETER
    # =========================================================================
    
    def interpret_gann_analysis(self, symbol: str, gann_data: Dict) -> str:
        """
        GANN INTERPRETER: Natural language analysis of Gann levels.
        Speaks as W.D. Gann would about the technical setup.
        """
        system_prompt = """You are W.D. Gann, the legendary trader known for geometric and 
time-cycle analysis. Interpret the Gann data and provide actionable insights.
Be specific about price levels, timing windows, and probability zones.
Speak in first person as Gann would."""
        
        sq9 = gann_data.get('square_of_9', {})
        cycles = gann_data.get('time_cycles', {})
        confluence = gann_data.get('confluence', {})
        
        # Format cycle data
        cycle_str = ""
        for name, data in cycles.get('cycles', {}).items():
            turn_status = "⚠️ TURN ZONE" if data.get('in_turn_zone') else ""
            cycle_str += f"  {name}: Day {data['day']}/{data['of']} ({data['progress_pct']}%) {turn_status}\n"
        
        prompt = f"""Interpret this Gann analysis for {symbol}:

CURRENT PRICE: ${gann_data.get('current_price', 0):.2f}

SQUARE OF 9 LEVELS:
- Resistance: {[f"${r['price']} ({r['type']})" for r in sq9.get('resistance', [])[:3]]}
- Support: {[f"${s['price']} ({s['type']})" for s in sq9.get('support', [])[:3]]}

TIME CYCLES (from last pivot):
{cycle_str}

CONFLUENCE SCORE: {confluence.get('score', 0)}/100 - {confluence.get('zone', 'N/A')}
Factors: {confluence.get('factors', [])}

SEASONAL: Next {gann_data.get('seasonal', {}).get('next_seasonal', 'N/A')} in {gann_data.get('seasonal', {}).get('days_away', 'N/A')} days

As W.D. Gann, interpret these numbers. What price targets and timing windows do you see?
What is the highest probability trade setup?"""

        response = self._call_api(prompt, system_prompt)
        return response or "Gann interpretation unavailable - Ollama offline"
    
    # =========================================================================
    # INTEGRATION #3: TRADE ADVISOR
    # =========================================================================
    
    def generate_trade_plan(self, symbol: str, all_signals: Dict, market_data: Dict) -> Dict:
        """
        TRADE ADVISOR: Final recommendation synthesizing all agent signals.
        Provides complete trade plan with entry, stop, targets.
        """
        system_prompt = """You are a senior options trader at a quantitative hedge fund.
Synthesize all trading signals into ONE clear recommendation.

Your response MUST start with exactly one of:
- "RECOMMENDATION: BUY [SYMBOL] CALLS"
- "RECOMMENDATION: BUY [SYMBOL] PUTS"
- "RECOMMENDATION: NO TRADE"

Then provide:
1. Strike selection rationale
2. Expiration recommendation  
3. Entry zone
4. Stop loss level
5. Profit targets (2 levels)
6. Position sizing (% of account)
7. Risk assessment (1-10 scale)"""

        prompt = f"""Generate trade plan for {symbol}:

CURRENT PRICE: ${market_data.get('current_price', 0):.2f}
ATR (14): ${market_data.get('atr', 0):.2f}

═══════════════════════════════════════
AGENT VOTES:
═══════════════════════════════════════
1. Base Confluence Agent: {all_signals.get('base_agent', {}).get('signal', 'N/A')}
2. Gann-Elliott Agent: {all_signals.get('gann_agent', {}).get('signal', 'N/A')}
3. DQN/RL Agent: {all_signals.get('dqn_agent', {}).get('signal', 'N/A')}
4. Ollama LLM Agent: {all_signals.get('ollama_agent', {}).get('signal', 'N/A')}

CONSENSUS: {all_signals.get('consensus_direction', 'N/A')}
AGREEMENT: {all_signals.get('agreement_count', 0)}/4 agents
SIGNAL STRENGTH: {all_signals.get('signal_strength', 'N/A')}

═══════════════════════════════════════
GANN LEVELS:
═══════════════════════════════════════
- Support: ${market_data.get('gann_support', 0):.2f}
- Resistance: ${market_data.get('gann_resistance', 0):.2f}
- Confluence: {market_data.get('gann_confluence', 0)}/100
- Turn Type: {market_data.get('turn_type', 'N/A')}

Generate your trade recommendation. Be specific about strike, expiry, entry, stop, and targets."""

        response = self._call_api(prompt, system_prompt)
        
        if not response:
            return {
                'recommendation': 'NO TRADE',
                'reasoning': 'Trade advisor unavailable - Ollama offline',
                'trade_plan': None
            }
        
        response_upper = response.upper()
        if f'BUY {symbol.upper()} CALLS' in response_upper:
            recommendation = f'BUY {symbol} CALLS'
            direction = 'CALL'
        elif f'BUY {symbol.upper()} PUTS' in response_upper:
            recommendation = f'BUY {symbol} PUTS'
            direction = 'PUT'
        else:
            recommendation = 'NO TRADE'
            direction = 'NONE'
        
        # Extract trade plan
        current_price = market_data.get('current_price', 0)
        atr = market_data.get('atr', 1)
        
        trade_plan = {
            'symbol': symbol,
            'direction': direction,
            'strike': round(current_price),
            'expiry': '7-14 DTE',
            'entry_low': round(current_price - atr * 0.25, 2),
            'entry_high': round(current_price + atr * 0.25, 2),
            'stop_loss': round(current_price - atr * 1.5, 2) if direction == 'CALL' else round(current_price + atr * 1.5, 2),
            'target_1': round(current_price + atr * 2, 2) if direction == 'CALL' else round(current_price - atr * 2, 2),
            'target_2': round(current_price + atr * 3, 2) if direction == 'CALL' else round(current_price - atr * 3, 2),
        }
        
        return {
            'recommendation': recommendation,
            'reasoning': response,
            'trade_plan': trade_plan
        }

# Initialize Ollama client
ollama = OllamaClient()

# =========================================================================
# GANN SQUARE OF 9
# =========================================================================

class GannSquareOf9:
    KEY_ANGLES = [45, 90, 135, 180, 225, 270, 315, 360]
    CARDINAL_ANGLES = [90, 180, 270, 360]
    
    @staticmethod
    def calculate_levels(price: float, increments: int = 5) -> Dict:
        sqrt_price = math.sqrt(price)
        resistance, support = [], []
        
        for i in range(1, increments + 1):
            for angle in GannSquareOf9.KEY_ANGLES:
                deg_inc = (angle / 180.0) * i
                
                r_price = round((sqrt_price + deg_inc) ** 2, 2)
                if r_price > price:
                    resistance.append({
                        'price': r_price, 'angle': angle * i,
                        'pct_away': round((r_price - price) / price * 100, 2),
                        'type': 'CARDINAL' if angle in GannSquareOf9.CARDINAL_ANGLES else 'ORDINAL'
                    })
                
                s_sqrt = sqrt_price - deg_inc
                if s_sqrt > 0:
                    s_price = round(s_sqrt ** 2, 2)
                    if s_price < price:
                        support.append({
                            'price': s_price, 'angle': angle * i,
                            'pct_away': round((price - s_price) / price * 100, 2),
                            'type': 'CARDINAL' if angle in GannSquareOf9.CARDINAL_ANGLES else 'ORDINAL'
                        })
        
        seen_r, unique_r = set(), []
        for r in sorted(resistance, key=lambda x: x['price']):
            if r['price'] not in seen_r:
                seen_r.add(r['price'])
                unique_r.append(r)
        
        seen_s, unique_s = set(), []
        for s in sorted(support, key=lambda x: x['price'], reverse=True):
            if s['price'] not in seen_s:
                seen_s.add(s['price'])
                unique_s.append(s)
        
        return {
            'current_price': price, 'sqrt_price': round(sqrt_price, 4),
            'resistance': unique_r[:increments], 'support': unique_s[:increments]
        }

# =========================================================================
# GANN TIME CYCLES
# =========================================================================

class GannTimeCycles:
    CYCLES = {'30-day': 30, '45-day': 45, '60-day': 60, '90-day': 90,
              '120-day': 120, '144-day': 144, '180-day': 180, '360-day': 360}
    
    @staticmethod
    def calculate_cycle_position(pivot_date: datetime, current_date: datetime) -> Dict:
        days_from_pivot = (current_date - pivot_date).days
        cycle_status = {}
        upcoming_turns = []
        
        for name, length in GannTimeCycles.CYCLES.items():
            position = days_from_pivot % length
            days_to_turn = length - position
            cycle_status[name] = {
                'day': position, 'of': length,
                'progress_pct': round(position / length * 100, 1),
                'days_to_turn': days_to_turn,
                'in_turn_zone': days_to_turn <= 3 or position <= 3
            }
            if days_to_turn <= 5:
                upcoming_turns.append({'cycle': name, 'days_away': days_to_turn})
        
        return {
            'days_from_pivot': days_from_pivot,
            'pivot_date': pivot_date.strftime('%Y-%m-%d'),
            'cycles': cycle_status,
            'upcoming_turns': sorted(upcoming_turns, key=lambda x: x['days_away'])
        }
    
    @staticmethod
    def days_to_next_seasonal(current_date: datetime) -> Dict:
        year = current_date.year
        seasonal = [
            ('Spring Equinox', datetime(year, 3, 21)),
            ('Summer Solstice', datetime(year, 6, 21)),
            ('Fall Equinox', datetime(year, 9, 21)),
            ('Winter Solstice', datetime(year, 12, 21)),
            ('Spring Equinox', datetime(year + 1, 3, 21)),
        ]
        for name, dt in seasonal:
            if dt > current_date:
                return {'next_seasonal': name, 'date': dt.strftime('%Y-%m-%d'), 'days_away': (dt - current_date).days}
        return {'next_seasonal': 'Unknown', 'date': 'N/A', 'days_away': 999}

# =========================================================================
# GANN ANGLES
# =========================================================================

class GannAngles:
    ANGLES = {'8x1': (8, 1), '4x1': (4, 1), '2x1': (2, 1), '1x1': (1, 1),
              '1x2': (1, 2), '1x4': (1, 4), '1x8': (1, 8)}
    
    @staticmethod
    def calculate_levels(pivot_price: float, pivot_date: datetime, 
                         current_date: datetime, is_pivot_low: bool = True) -> Dict:
        days = max((current_date - pivot_date).days, 1)
        angles = {}
        
        for name, (p_units, t_units) in GannAngles.ANGLES.items():
            price_per_day = p_units / t_units
            change = price_per_day * days
            proj = pivot_price + change if is_pivot_low else pivot_price - change
            angles[name] = {'price': round(proj, 2), 'per_day': round(price_per_day, 4)}
        
        return {'pivot': pivot_price, 'days': days, 'type': 'LOW' if is_pivot_low else 'HIGH', 'angles': angles}
    
    @staticmethod
    def get_position(current_price: float, angle_levels: Dict) -> Dict:
        angles = angle_levels['angles']
        above = [n for n, d in angles.items() if current_price > d['price']]
        below = [n for n, d in angles.items() if current_price <= d['price']]
        nearest = min(angles.items(), key=lambda x: abs(current_price - x[1]['price']))
        return {'above': above, 'below': below, 'nearest': nearest[0], 'nearest_price': nearest[1]['price']}

# =========================================================================
# CONFLUENCE SCORER
# =========================================================================

def calculate_gann_confluence(price: float, sq9: Dict, cycles: Dict, angles: Dict) -> Dict:
    score = 0
    factors = []
    
    # Price near SQ9 level (+25)
    nearest_s = sq9['support'][0] if sq9['support'] else None
    nearest_r = sq9['resistance'][0] if sq9['resistance'] else None
    
    if nearest_s and nearest_s['pct_away'] < 1.5:
        score += 25 if nearest_s['type'] == 'CARDINAL' else 20
        factors.append(f"Near SQ9 support ${nearest_s['price']}")
    elif nearest_r and nearest_r['pct_away'] < 1.5:
        score += 25 if nearest_r['type'] == 'CARDINAL' else 20
        factors.append(f"Near SQ9 resistance ${nearest_r['price']}")
    
    # Time near cycle turn (+25)
    turns = [n for n, d in cycles['cycles'].items() if d['in_turn_zone']]
    if len(turns) >= 3:
        score += 25
        factors.append(f"Multiple cycles turning: {', '.join(turns)}")
    elif turns:
        score += 15
        factors.append(f"Cycle turn: {turns[0]}")
    
    # Price on Gann angle (+25)
    if angles.get('nearest_price'):
        dist = abs(price - angles['nearest_price']) / price
        if dist < 0.005:
            score += 25
            factors.append(f"On {angles['nearest']} angle")
        elif dist < 0.01:
            score += 15
            factors.append(f"Near {angles['nearest']} angle")
    
    # Converging cycles (+25)
    upcoming = cycles.get('upcoming_turns', [])
    if len(upcoming) >= 3:
        score += 25
        factors.append(f"{len(upcoming)} cycles converging")
    elif len(upcoming) >= 2:
        score += 15
    
    zone = "HIGH PROBABILITY" if score >= 75 else "MODERATE" if score >= 50 else "LOW" if score >= 25 else "NONE"
    return {'score': score, 'zone': zone, 'factors': factors}

# =========================================================================
# TURN DIRECTION PREDICTOR
# =========================================================================

@dataclass
class TurnPrediction:
    symbol: str
    turn_type: TurnType
    timeframe: Timeframe
    options_action: OptionsAction
    direction: str
    confidence: float
    support: float
    resistance: float
    entry: float
    stop: float
    target1: float
    target2: float
    expiry: str
    strike: str
    rationale: str
    gann_score: int
    
    def to_dict(self) -> dict:
        action = self.options_action.value.replace("CALLS", f"{self.symbol} CALLS").replace("PUTS", f"{self.symbol} PUTS")
        return {
            "Symbol": self.symbol, "Timeframe": self.timeframe.value, "TurnType": self.turn_type.value,
            "OptionsAction": action, "Direction": self.direction, "Confidence": self.confidence,
            "GannScore": self.gann_score, "Support": self.support, "Resistance": self.resistance,
            "Entry": self.entry, "Stop": self.stop, "Target1": self.target1, "Target2": self.target2,
            "Expiry": self.expiry, "Strike": self.strike, "Rationale": self.rationale
        }

def predict_turn(df: pd.DataFrame, symbol: str, timeframe: Timeframe, sq9: Dict, confluence: Dict) -> TurnPrediction:
    """Predict turn direction using Gann analysis."""
    if len(df) < 20:
        return TurnPrediction(symbol, TurnType.NO_TURN, timeframe, OptionsAction.NO_ACTION, "NEUTRAL",
                              0, 0, 0, 0, 0, 0, 0, "N/A", "N/A", "Insufficient data", 0)
    
    price = df['close'].iloc[-1]
    atr = calculate_atr(df)
    
    support = sq9['support'][0]['price'] if sq9['support'] else price * 0.95
    resistance = sq9['resistance'][0]['price'] if sq9['resistance'] else price * 1.05
    
    sma20 = df['close'].rolling(20).mean().iloc[-1]
    sma50 = df['close'].rolling(min(50, len(df))).mean().iloc[-1]
    trend_up = price > sma20 > sma50
    trend_down = price < sma20 < sma50
    
    vol_avg = df['volume'].rolling(20).mean().iloc[-1]
    vol_recent = df['volume'].iloc[-5:].mean()
    vol_expanding = vol_recent > vol_avg * 1.2
    
    near_support = abs(price - support) < atr * 0.5
    near_resistance = abs(price - resistance) < atr * 0.5
    below_support = price < support - atr * 0.25
    above_resistance = price > resistance + atr * 0.25
    
    # Determine turn type
    if below_support and vol_expanding:
        turn, action, direction = TurnType.BREAKDOWN, OptionsAction.BUY_PUTS, "DOWN"
        conf = 75 + (15 if trend_down else 0) + confluence['score'] * 0.1
        rationale = f"BREAKDOWN below SQ9 ${support:.2f} with volume"
    elif above_resistance and vol_expanding:
        turn, action, direction = TurnType.BREAKOUT, OptionsAction.BUY_CALLS, "UP"
        conf = 75 + (15 if trend_up else 0) + confluence['score'] * 0.1
        rationale = f"BREAKOUT above SQ9 ${resistance:.2f} with volume"
    elif trend_up and near_support:
        turn, action, direction = TurnType.PULLBACK, OptionsAction.BUY_CALLS, "UP"
        conf = 70 + (10 if confluence['score'] >= 50 else 0)
        rationale = f"PULLBACK to support ${support:.2f} in uptrend"
    elif trend_down and near_resistance:
        turn, action, direction = TurnType.PULLBACK, OptionsAction.BUY_PUTS, "DOWN"
        conf = 70 + (10 if confluence['score'] >= 50 else 0)
        rationale = f"PULLBACK to resistance ${resistance:.2f} in downtrend"
    elif near_support and not trend_down:
        turn, action, direction = TurnType.BOUNCE, OptionsAction.BUY_CALLS, "UP"
        conf = 65
        rationale = f"BOUNCE at support ${support:.2f}"
    else:
        turn, action, direction = TurnType.NO_TURN, OptionsAction.NO_ACTION, "NEUTRAL"
        conf = 40
        rationale = "No clear turn signal"
    
    conf = min(conf, 100)
    
    if direction == "UP":
        stop, t1, t2 = support - atr * 0.5, resistance, resistance + (resistance - support) * 0.5
    elif direction == "DOWN":
        stop, t1, t2 = resistance + atr * 0.5, support, support - (resistance - support) * 0.5
    else:
        stop = t1 = t2 = price
    
    expiry = {"15 Min": "1-3 DTE", "Daily": "7-14 DTE", "Weekly": "14-30 DTE"}.get(timeframe.value, "7-14 DTE")
    strike = f"ATM ${round(price)}" if direction != "NEUTRAL" else "N/A"
    
    return TurnPrediction(symbol, turn, timeframe, action, direction, conf, support, resistance,
                          price, stop, t1, t2, expiry, strike, rationale, confluence['score'])

def calculate_atr(df: pd.DataFrame, period: int = 14) -> float:
    if len(df) < 2:
        return 1.0
    h, l, c = df['high'].values, df['low'].values, df['close'].values
    tr = [max(h[i] - l[i], abs(h[i] - c[i-1]), abs(l[i] - c[i-1])) for i in range(1, len(df))]
    return sum(tr[-period:]) / min(period, len(tr)) if tr else 1.0

# =========================================================================
# MULTI-AGENT CONSENSUS SYSTEM
# =========================================================================

def calculate_consensus(agents: Dict) -> Dict:
    """
    Calculate consensus from all 4 agents.
    
    Returns signal strength based on agreement:
    - 4/4 = ULTRA (89% target win rate)
    - 3/4 = SUPER (78% target win rate)
    - 2/4 = MODERATE (65% target win rate)
    - 1/4 or 0/4 = NO TRADE
    """
    votes = {'CALL': 0, 'PUT': 0, 'NEUTRAL': 0}
    
    for agent_name, agent_data in agents.items():
        signal = agent_data.get('signal', 'NEUTRAL').upper()
        if signal in votes:
            votes[signal] += 1
    
    # Determine consensus
    max_votes = max(votes.values())
    if votes['CALL'] == max_votes and votes['CALL'] > votes['PUT']:
        direction = 'CALL'
    elif votes['PUT'] == max_votes and votes['PUT'] > votes['CALL']:
        direction = 'PUT'
    else:
        direction = 'NEUTRAL'
    
    agreement = votes[direction] if direction != 'NEUTRAL' else 0
    
    # Signal strength
    if agreement == 4:
        strength = SignalStrength.ULTRA
        win_rate = 89
    elif agreement == 3:
        strength = SignalStrength.SUPER
        win_rate = 78
    elif agreement == 2:
        strength = SignalStrength.MODERATE
        win_rate = 65
    elif agreement == 1:
        strength = SignalStrength.WEAK
        win_rate = 55
    else:
        strength = SignalStrength.NONE
        win_rate = 0
    
    return {
        'consensus_direction': direction,
        'agreement_count': agreement,
        'signal_strength': strength.value,
        'target_win_rate': win_rate,
        'votes': votes
    }

# =========================================================================
# DATA FETCHING
# =========================================================================

@dataclass
class Bar:
    d: str
    open_: float
    high: float
    low: float
    close: float
    volume: float

def fetch_data(symbol: str, start_date: str) -> List[Bar]:
    """Fetch data from Tiingo."""
    token = TIINGO_TOKEN
    if not token:
        logger.error("TIINGO_TOKEN not set!")
        return []
    
    url = f"https://api.tiingo.com/tiingo/daily/{symbol}/prices?startDate={start_date}&token={token}"
    
    try:
        req = urllib.request.Request(url)
        req.add_header('User-Agent', 'StockAgent/1.0')
        
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read().decode('utf-8'))
            return [Bar(i['date'], i['open'], i['high'], i['low'], i['close'], i['volume']) for i in data]
    except Exception as e:
        logger.error(f"Fetch error: {e}")
        return []

def bars_to_df(bars: List[Bar]) -> pd.DataFrame:
    if not bars:
        return pd.DataFrame()
    return pd.DataFrame({
        'open': [b.open_ for b in bars], 'high': [b.high for b in bars],
        'low': [b.low for b in bars], 'close': [b.close for b in bars],
        'volume': [b.volume for b in bars]
    }, index=pd.to_datetime([b.d for b in bars]))

# =========================================================================
# OUTPUT
# =========================================================================

DATA_DIR = pathlib.Path("data")
REPORT_DIR = pathlib.Path("reports")
DATA_DIR.mkdir(exist_ok=True)
REPORT_DIR.mkdir(exist_ok=True)

def write_predictions(predictions: List[TurnPrediction]) -> None:
    path = REPORT_DIR / "gann_turn_predictions.csv"
    with path.open('w', newline='') as f:
        w = csv.DictWriter(f, fieldnames=["Symbol", "Timeframe", "TurnType", "OptionsAction", "Direction",
                                          "Confidence", "GannScore", "Support", "Resistance", "Entry",
                                          "Stop", "Target1", "Target2", "Expiry", "Strike", "Rationale"])
        w.writeheader()
        for p in predictions:
            w.writerow(p.to_dict())
    logger.info(f"Wrote {len(predictions)} predictions to {path}")

def write_consensus(consensus: Dict, agents: Dict, trade_plan: Dict, symbol: str) -> None:
    path = REPORT_DIR / f"consensus_{symbol}.json"
    output = {
        'symbol': symbol,
        'timestamp': datetime.now().isoformat(),
        'consensus': consensus,
        'agents': {k: {'signal': v.get('signal'), 'confidence': v.get('confidence')} for k, v in agents.items()},
        'trade_plan': trade_plan
    }
    path.write_text(json.dumps(output, indent=2))
    logger.info(f"Wrote consensus to {path}")

def write_gann_json(symbol: str, price: float, sq9: Dict, cycles: Dict, angles: Dict, confluence: Dict) -> None:
    path = DATA_DIR / f"gann_analysis_{symbol}.json"
    output = {
        'symbol': symbol, 'timestamp': datetime.now().isoformat(), 'current_price': price,
        'square_of_9': sq9, 'time_cycles': cycles, 'gann_angles': angles, 'confluence': confluence,
        'seasonal': GannTimeCycles.days_to_next_seasonal(datetime.now())
    }
    path.write_text(json.dumps(output, indent=2, default=str))
    logger.info(f"Wrote Gann analysis to {path}")

# =========================================================================
# MAIN
# =========================================================================

def main():
    symbol = ACTIVE_SYMBOL
    
    logger.info("=" * 80)
    logger.info(f"MULTI-AGENT CONSENSUS SYSTEM - {symbol}")
    logger.info(f"Agents: Base Confluence | Gann-Elliott | DQN/RL | Ollama LLM")
    logger.info(f"Ollama: {'ENABLED' if ollama.enabled else 'DISABLED'} (Model: {OLLAMA_MODEL})")
    logger.info("=" * 80)
    
    # Fetch data
    bars = fetch_data(symbol, "2022-11-01")
    if not bars:
        logger.error("No data fetched!")
        return
    
    df = bars_to_df(bars)
    price = df['close'].iloc[-1]
    atr = calculate_atr(df)
    
    logger.info(f"\n{symbol} @ ${price:.2f} | ATR: ${atr:.2f}")
    
    # =========================================================================
    # GANN ANALYSIS
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("GANN ANALYSIS")
    logger.info("=" * 80)
    
    sq9 = GannSquareOf9.calculate_levels(price)
    logger.info(f"Square of 9: R={[f'${r[\"price\"]}' for r in sq9['resistance'][:3]]} | S={[f'${s[\"price\"]}' for s in sq9['support'][:3]]}")
    
    pivot_date = datetime.now() - timedelta(days=30)
    cycles = GannTimeCycles.calculate_cycle_position(pivot_date, datetime.now())
    
    angle_levels = GannAngles.calculate_levels(price * 0.95, pivot_date, datetime.now(), True)
    angle_pos = GannAngles.get_position(price, angle_levels)
    
    confluence = calculate_gann_confluence(price, sq9, cycles, angle_pos)
    logger.info(f"Confluence: {confluence['score']}/100 - {confluence['zone']}")
    
    write_gann_json(symbol, price, sq9, cycles, angle_levels, confluence)
    
    # Gann data for Ollama
    gann_data = {
        'current_price': price,
        'square_of_9': sq9,
        'time_cycles': cycles,
        'confluence': confluence,
        'seasonal': GannTimeCycles.days_to_next_seasonal(datetime.now())
    }
    
    # =========================================================================
    # AGENT SIGNALS
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("AGENT SIGNALS")
    logger.info("=" * 80)
    
    sma20 = df['close'].rolling(20).mean().iloc[-1]
    sma50 = df['close'].rolling(min(50, len(df))).mean().iloc[-1]
    trend = "UPTREND" if price > sma20 > sma50 else "DOWNTREND" if price < sma20 < sma50 else "SIDEWAYS"
    
    # Agent 1: Base Confluence
    base_signal = "CALL" if sma20 > sma50 else "PUT"
    base_agent = {'signal': base_signal, 'confidence': 70, 'reasoning': f"SMA crossover: {trend}"}
    logger.info(f"1. Base Confluence: {base_signal} ({trend})")
    
    # Agent 2: Gann-Elliott
    gann_support = sq9['support'][0]['price'] if sq9['support'] else price * 0.95
    gann_resistance = sq9['resistance'][0]['price'] if sq9['resistance'] else price * 1.05
    
    if abs(price - gann_support) < abs(price - gann_resistance):
        gann_signal = "CALL"  # Near support = bullish
    else:
        gann_signal = "PUT"   # Near resistance = bearish
    
    if confluence['score'] >= 75:
        gann_confidence = 85
    elif confluence['score'] >= 50:
        gann_confidence = 70
    else:
        gann_confidence = 55
    
    gann_agent = {'signal': gann_signal, 'confidence': gann_confidence, 'reasoning': f"Gann confluence: {confluence['score']}/100"}
    logger.info(f"2. Gann-Elliott: {gann_signal} (Confluence: {confluence['score']}/100)")
    
    # Agent 3: DQN/RL (simplified momentum-based)
    momentum = (price - df['close'].iloc[-10]) / df['close'].iloc[-10] * 100
    dqn_signal = "CALL" if momentum > 1 else "PUT" if momentum < -1 else "NEUTRAL"
    dqn_agent = {'signal': dqn_signal, 'confidence': 65, 'reasoning': f"10-day momentum: {momentum:.2f}%"}
    logger.info(f"3. DQN/RL: {dqn_signal} (Momentum: {momentum:.2f}%)")
    
    # Agent 4: Ollama LLM
    price_data = {
        'current_price': price, 'sma_20': sma20, 'sma_50': sma50, 'atr': atr,
        'trend': trend, 'volume_ratio': df['volume'].iloc[-1] / df['volume'].mean(),
        'gann_support': gann_support, 'gann_resistance': gann_resistance,
        'gann_confluence': confluence['score'], 'turn_type': 'PULLBACK',
        'base_signal': base_signal, 'gann_signal': gann_signal
    }
    
    ollama_result = ollama.analyze_market_sentiment(symbol, price_data)
    ollama_agent = {'signal': ollama_result['signal'], 'confidence': ollama_result['confidence'], 
                    'reasoning': ollama_result['reasoning'][:200]}
    logger.info(f"4. Ollama LLM: {ollama_result['signal']} (via {OLLAMA_MODEL})")
    
    # =========================================================================
    # CONSENSUS CALCULATION
    # =========================================================================
    agents = {
        'base_agent': base_agent,
        'gann_agent': gann_agent,
        'dqn_agent': dqn_agent,
        'ollama_agent': ollama_agent
    }
    
    consensus = calculate_consensus(agents)
    
    logger.info("\n" + "=" * 80)
    logger.info("CONSENSUS")
    logger.info("=" * 80)
    logger.info(f"Direction: {consensus['consensus_direction']}")
    logger.info(f"Agreement: {consensus['agreement_count']}/4 agents")
    logger.info(f"Strength: {consensus['signal_strength']}")
    logger.info(f"Target Win Rate: {consensus['target_win_rate']}%")
    logger.info(f"Votes: CALL={consensus['votes']['CALL']}, PUT={consensus['votes']['PUT']}, NEUTRAL={consensus['votes']['NEUTRAL']}")
    
    # =========================================================================
    # OLLAMA INTEGRATION #2: GANN INTERPRETER
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("GANN INTERPRETATION (Ollama)")
    logger.info("=" * 80)
    
    gann_interpretation = ollama.interpret_gann_analysis(symbol, gann_data)
    logger.info(gann_interpretation[:1000] if gann_interpretation else "Unavailable")
    
    # =========================================================================
    # OLLAMA INTEGRATION #3: TRADE ADVISOR
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("TRADE ADVISOR (Ollama)")
    logger.info("=" * 80)
    
    market_data = {
        'current_price': price, 'atr': atr,
        'gann_support': gann_support, 'gann_resistance': gann_resistance,
        'gann_confluence': confluence['score'], 'turn_type': 'PULLBACK'
    }
    
    all_signals = {**agents, **consensus}
    trade_advice = ollama.generate_trade_plan(symbol, all_signals, market_data)
    
    logger.info(f"RECOMMENDATION: {trade_advice['recommendation']}")
    if trade_advice.get('trade_plan'):
        tp = trade_advice['trade_plan']
        logger.info(f"  Strike: ${tp.get('strike', 'N/A')} | Expiry: {tp.get('expiry', 'N/A')}")
        logger.info(f"  Entry: ${tp.get('entry_low', 0):.2f} - ${tp.get('entry_high', 0):.2f}")
        logger.info(f"  Stop: ${tp.get('stop_loss', 0):.2f} | T1: ${tp.get('target_1', 0):.2f} | T2: ${tp.get('target_2', 0):.2f}")
    
    # =========================================================================
    # TURN PREDICTIONS
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("TURN PREDICTIONS")
    logger.info("=" * 80)
    
    predictions = [
        predict_turn(df, symbol, Timeframe.DAILY, sq9, confluence),
        predict_turn(df.tail(20), symbol, Timeframe.MIN_15, sq9, confluence),
    ]
    
    for p in predictions:
        action = p.options_action.value.replace("CALLS", f"{symbol} CALLS").replace("PUTS", f"{symbol} PUTS")
        logger.info(f"[{p.timeframe.value}] {p.turn_type.value} → {action} | Conf: {p.confidence:.0f}%")
    
    write_predictions(predictions)
    write_consensus(consensus, agents, trade_advice, symbol)
    
    # =========================================================================
    # FINAL SUMMARY
    # =========================================================================
    logger.info("\n" + "=" * 80)
    logger.info("FINAL SUMMARY")
    logger.info("=" * 80)
    logger.info(f"Symbol: {symbol} @ ${price:.2f}")
    logger.info(f"Consensus: {consensus['signal_strength']} {consensus['consensus_direction']} ({consensus['agreement_count']}/4)")
    logger.info(f"Gann Confluence: {confluence['score']}/100 ({confluence['zone']})")
    logger.info(f"Trade Recommendation: {trade_advice['recommendation']}")
    logger.info("=" * 80)

if __name__ == "__main__":
    main()
