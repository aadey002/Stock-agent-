#!/usr/bin/env python3
"""
SPY Confluence Agent with Playbook, Tuning, and Gann‚ÄìElliott Super-Confluence
WEEK 3 ENHANCEMENTS: 
- Dynamic ETF Selection (not hardcoded SPY)
- Full Gann Analysis: Square of 9, Time Cycles, Gann Angles
- Turn Direction Predictor (PULLBACK vs BREAKDOWN)
- Clear Options Recommendations with Timeframes
- Works offline (no Ollama dependency)

What this script does
---------------------
1. Fetches daily prices for SELECTED ETF from Tiingo (with retry logic).
2. Saves raw history to data/{SYMBOL}.csv.
3. Computes: ATR, SMAs, geometry/phi/time confluence markers
4. Generates CALL or PUT playbook with ATR-based stops/targets
5. Full Gann Analysis:
   - Square of 9 support/resistance levels
   - Time Cycles (30, 45, 60, 90, 120, 144, 180, 360 days)
   - Gann Angles (1x1, 2x1, 1x2, etc.)
   - Confluence scoring (0-100)
6. Turn Direction Predictor:
   - PULLBACK: Temporary retracement, trend continues
   - BREAKDOWN: Support fails, trend reverses
   - BREAKOUT: Resistance breaks, new uptrend
   - BOUNCE: Support holds, reversal up
7. Clear Options Recommendations:
   - "BUY {SYMBOL} CALLS" or "BUY {SYMBOL} PUTS"
   - Timeframe labels: Daily, 15 Min, Weekly, etc.
   - Strike and expiry suggestions

NOTE: This is a research tool, not trading advice.
"""

import csv
import json
import logging
import math
import os
import pathlib
import time
import urllib.error
import urllib.request
from dataclasses import dataclass, field
from datetime import date, datetime, timedelta
from typing import List, Tuple, Optional, Dict
from enum import Enum
from statistics import median
import pandas as pd

# =========================================================================
# CONFIGURATION - DYNAMIC SYMBOL SELECTION
# =========================================================================

# SUPPORTED ETFs - Change ACTIVE_SYMBOL to trade different ETF
SUPPORTED_SYMBOLS = ["SPY", "QQQ", "IWM", "DIA", "XLF", "XLE", "XLK", "XLV", "XLI", "XLU", "GLD", "TLT"]

# *** CHANGE THIS TO SELECT DIFFERENT ETF ***
ACTIVE_SYMBOL = os.getenv("TRADING_SYMBOL", "SPY")

# Validate symbol
if ACTIVE_SYMBOL not in SUPPORTED_SYMBOLS:
    print(f"WARNING: {ACTIVE_SYMBOL} not in supported list. Defaulting to SPY.")
    ACTIVE_SYMBOL = "SPY"

# =========================================================================
# ENUMS FOR TURN TYPES AND TIMEFRAMES
# =========================================================================

class TurnType(Enum):
    """Type of market turn predicted by Gann analysis."""
    PULLBACK = "PULLBACK"      # Temporary retracement, trend continues
    BREAKDOWN = "BREAKDOWN"    # Support fails, trend reverses DOWN
    BREAKOUT = "BREAKOUT"      # Resistance breaks, trend reverses UP
    BOUNCE = "BOUNCE"          # Support holds, reversal UP
    NO_TURN = "NO_TURN"        # No significant turn detected

class Timeframe(Enum):
    """Chart timeframes for analysis."""
    MIN_1 = "1 Min"
    MIN_5 = "5 Min"
    MIN_15 = "15 Min"
    MIN_30 = "30 Min"
    HOURLY = "1 Hour"
    DAILY = "Daily"
    WEEKLY = "Weekly"
    MONTHLY = "Monthly"

class OptionsAction(Enum):
    """Clear options trading actions."""
    BUY_CALLS = "BUY CALLS"
    BUY_PUTS = "BUY PUTS"
    SELL_CALLS = "SELL CALLS"
    SELL_PUTS = "SELL PUTS"
    NO_ACTION = "NO ACTION - WAIT"

# =========================================================================
# GANN SQUARE OF 9 CALCULATOR
# =========================================================================

class GannSquareOf9:
    """
    Gann Square of 9 Calculator
    
    The Square of 9 uses the formula:
    New Price = (sqrt(Base Price) + n/4)^2
    Where n = number of 90-degree rotations
    
    Key angles: 45¬∞, 90¬∞, 135¬∞, 180¬∞, 225¬∞, 270¬∞, 315¬∞, 360¬∞
    """
    
    KEY_ANGLES = [45, 90, 135, 180, 225, 270, 315, 360]
    CARDINAL_ANGLES = [90, 180, 270, 360]
    ORDINAL_ANGLES = [45, 135, 225, 315]
    
    @staticmethod
    def calculate_levels(price: float, increments: int = 5) -> Dict:
        """Calculate Square of 9 support/resistance levels."""
        sqrt_price = math.sqrt(price)
        
        resistance = []
        support = []
        
        for i in range(1, increments + 1):
            for angle in GannSquareOf9.KEY_ANGLES:
                deg_inc = (angle / 180.0) * i
                
                r_sqrt = sqrt_price + deg_inc
                r_price = round(r_sqrt ** 2, 2)
                if r_price > price:
                    resistance.append({
                        'price': r_price,
                        'angle': angle * i,
                        'pct_away': round((r_price - price) / price * 100, 2),
                        'type': 'CARDINAL' if angle in GannSquareOf9.CARDINAL_ANGLES else 'ORDINAL'
                    })
                
                s_sqrt = sqrt_price - deg_inc
                if s_sqrt > 0:
                    s_price = round(s_sqrt ** 2, 2)
                    if s_price < price:
                        support.append({
                            'price': s_price,
                            'angle': angle * i,
                            'pct_away': round((price - s_price) / price * 100, 2),
                            'type': 'CARDINAL' if angle in GannSquareOf9.CARDINAL_ANGLES else 'ORDINAL'
                        })
        
        resistance = sorted(resistance, key=lambda x: x['price'])
        support = sorted(support, key=lambda x: x['price'], reverse=True)
        
        seen_r = set()
        unique_r = []
        for r in resistance:
            if r['price'] not in seen_r:
                seen_r.add(r['price'])
                unique_r.append(r)
        
        seen_s = set()
        unique_s = []
        for s in support:
            if s['price'] not in seen_s:
                seen_s.add(s['price'])
                unique_s.append(s)
        
        return {
            'current_price': price,
            'sqrt_price': round(sqrt_price, 4),
            'resistance': unique_r[:increments],
            'support': unique_s[:increments]
        }
    
    @staticmethod
    def calculate_cardinal_cross(price: float) -> Dict:
        """Calculate Cardinal Cross levels (90¬∞ intervals)."""
        sqrt_price = math.sqrt(price)
        levels = {'current': price, 'resistance': {}, 'support': {}}
        
        for angle in [90, 180, 270, 360]:
            deg_inc = angle / 180.0
            levels['resistance'][f'{angle}¬∞'] = round((sqrt_price + deg_inc) ** 2, 2)
            s_sqrt = sqrt_price - deg_inc
            if s_sqrt > 0:
                levels['support'][f'{angle}¬∞'] = round(s_sqrt ** 2, 2)
        
        return levels

# =========================================================================
# GANN TIME CYCLES
# =========================================================================

class GannTimeCycles:
    """Gann Time Cycle Calculator"""
    
    CYCLES = {
        '30-day': 30, '45-day': 45, '60-day': 60, '90-day': 90,
        '120-day': 120, '144-day': 144, '180-day': 180, '360-day': 360
    }
    DEGREE_CYCLES = [11, 22, 34, 45, 56, 67, 78, 90]
    
    @staticmethod
    def calculate_cycle_position(pivot_date: datetime, current_date: datetime) -> Dict:
        """Calculate current position in all Gann cycles."""
        days_from_pivot = (current_date - pivot_date).days
        
        cycle_status = {}
        upcoming_turns = []
        
        for cycle_name, cycle_length in GannTimeCycles.CYCLES.items():
            position = days_from_pivot % cycle_length
            progress = round(position / cycle_length * 100, 1)
            days_to_turn = cycle_length - position
            
            cycle_status[cycle_name] = {
                'day': position,
                'of': cycle_length,
                'progress_pct': progress,
                'days_to_turn': days_to_turn,
                'in_turn_zone': days_to_turn <= 3 or position <= 3
            }
            
            if days_to_turn <= 5:
                upcoming_turns.append({
                    'cycle': cycle_name,
                    'days_away': days_to_turn,
                    'expected_date': (current_date + timedelta(days=days_to_turn)).strftime('%Y-%m-%d')
                })
        
        degree_turns = []
        for deg_cycle in GannTimeCycles.DEGREE_CYCLES:
            if days_from_pivot <= deg_cycle:
                days_to_deg = deg_cycle - days_from_pivot
                if days_to_deg <= 5:
                    degree_turns.append({'degree_day': deg_cycle, 'days_away': days_to_deg})
        
        return {
            'days_from_pivot': days_from_pivot,
            'pivot_date': pivot_date.strftime('%Y-%m-%d'),
            'cycles': cycle_status,
            'upcoming_turns': sorted(upcoming_turns, key=lambda x: x['days_away']),
            'degree_turns': degree_turns
        }
    
    @staticmethod
    def get_seasonal_dates(year: int) -> Dict:
        """Get important Gann seasonal dates."""
        return {
            'spring_equinox': datetime(year, 3, 21),
            'summer_solstice': datetime(year, 6, 21),
            'fall_equinox': datetime(year, 9, 21),
            'winter_solstice': datetime(year, 12, 21)
        }
    
    @staticmethod
    def days_to_next_seasonal(current_date: datetime) -> Dict:
        """Calculate days to next seasonal date."""
        year = current_date.year
        seasonal = GannTimeCycles.get_seasonal_dates(year)
        
        all_dates = list(seasonal.items()) + list(GannTimeCycles.get_seasonal_dates(year + 1).items())
        
        for name, dt in sorted(all_dates, key=lambda x: x[1]):
            if dt > current_date:
                return {
                    'next_seasonal': name.replace('_', ' ').title(),
                    'date': dt.strftime('%Y-%m-%d'),
                    'days_away': (dt - current_date).days
                }
        return {'next_seasonal': 'Unknown', 'date': 'N/A', 'days_away': 999}

# =========================================================================
# GANN ANGLES
# =========================================================================

class GannAngles:
    """Gann Angle Calculator"""
    
    ANGLES = {
        '8x1': (8, 1), '4x1': (4, 1), '3x1': (3, 1), '2x1': (2, 1),
        '1x1': (1, 1), '1x2': (1, 2), '1x3': (1, 3), '1x4': (1, 4), '1x8': (1, 8),
    }
    
    @staticmethod
    def calculate_angle_levels(pivot_price: float, pivot_date: datetime, 
                                current_date: datetime, is_pivot_low: bool = True) -> Dict:
        """Calculate Gann angle levels from a pivot point."""
        days_from_pivot = max((current_date - pivot_date).days, 1)
        angle_levels = {}
        
        for angle_name, (price_units, time_units) in GannAngles.ANGLES.items():
            price_per_day = price_units / time_units
            price_change = price_per_day * days_from_pivot
            
            if is_pivot_low:
                projected_price = pivot_price + price_change
            else:
                projected_price = pivot_price - price_change
            
            angle_levels[angle_name] = {
                'projected_price': round(projected_price, 2),
                'price_per_day': round(price_per_day, 4),
                'is_support': is_pivot_low,
                'degrees': round(math.degrees(math.atan(price_per_day)), 2)
            }
        
        return {
            'pivot_price': pivot_price,
            'pivot_date': pivot_date.strftime('%Y-%m-%d'),
            'days_from_pivot': days_from_pivot,
            'pivot_type': 'LOW' if is_pivot_low else 'HIGH',
            'angles': angle_levels
        }
    
    @staticmethod
    def get_price_position(current_price: float, angle_levels: Dict) -> Dict:
        """Determine where current price sits relative to Gann angles."""
        angles = angle_levels['angles']
        
        above, below = [], []
        nearest, nearest_dist = None, float('inf')
        
        for name, data in angles.items():
            proj = data['projected_price']
            dist = abs(current_price - proj)
            
            if dist < nearest_dist:
                nearest_dist = dist
                nearest = name
            
            if current_price > proj:
                above.append(name)
            else:
                below.append(name)
        
        return {
            'current_price': current_price,
            'above_angles': above,
            'below_angles': below,
            'nearest_angle': nearest,
            'nearest_price': angles[nearest]['projected_price'] if nearest else None,
            'distance_to_nearest': round(nearest_dist, 2)
        }

# =========================================================================
# GANN CONFLUENCE SCORER
# =========================================================================

def calculate_gann_confluence(current_price: float, sq9_levels: Dict, 
                               cycle_status: Dict, angle_position: Dict) -> Dict:
    """Calculate Gann Confluence Score (0-100)."""
    score = 0
    factors = []
    
    # 1. Price near Square of 9 level (+25)
    sq9_score = 0
    nearest_support = sq9_levels['support'][0] if sq9_levels['support'] else None
    nearest_resistance = sq9_levels['resistance'][0] if sq9_levels['resistance'] else None
    
    if nearest_support and nearest_support['pct_away'] < 1.5:
        sq9_score = 25 if nearest_support['type'] == 'CARDINAL' else 20
        factors.append(f"Price near SQ9 support ${nearest_support['price']} ({nearest_support['pct_away']}%)")
    elif nearest_resistance and nearest_resistance['pct_away'] < 1.5:
        sq9_score = 25 if nearest_resistance['type'] == 'CARDINAL' else 20
        factors.append(f"Price near SQ9 resistance ${nearest_resistance['price']} ({nearest_resistance['pct_away']}%)")
    score += sq9_score
    
    # 2. Time near cycle turn (+25)
    time_score = 0
    cycles_in_turn = [name for name, data in cycle_status['cycles'].items() if data['in_turn_zone']]
    
    if len(cycles_in_turn) >= 3:
        time_score = 25
        factors.append(f"Multiple cycles in turn zone: {', '.join(cycles_in_turn)}")
    elif len(cycles_in_turn) >= 1:
        time_score = 15
        factors.append(f"Cycle in turn zone: {cycles_in_turn[0]}")
    score += time_score
    
    # 3. Price on Gann angle (+25)
    angle_score = 0
    if angle_position['distance_to_nearest'] < current_price * 0.005:
        angle_score = 25
        factors.append(f"Price on {angle_position['nearest_angle']} angle")
    elif angle_position['distance_to_nearest'] < current_price * 0.01:
        angle_score = 15
        factors.append(f"Price near {angle_position['nearest_angle']} angle")
    score += angle_score
    
    # 4. Multiple cycles converging (+25)
    converge_score = 0
    upcoming = cycle_status.get('upcoming_turns', [])
    if len(upcoming) >= 3:
        converge_score = 25
        factors.append(f"{len(upcoming)} cycles converging soon")
    elif len(upcoming) >= 2:
        converge_score = 15
        factors.append(f"{len(upcoming)} cycles converging")
    score += converge_score
    
    if score >= 75:
        zone = "HIGH PROBABILITY ZONE"
    elif score >= 50:
        zone = "MODERATE PROBABILITY"
    elif score >= 25:
        zone = "LOW PROBABILITY"
    else:
        zone = "NO CONFLUENCE"
    
    return {
        'score': score, 'max_score': 100, 'zone': zone, 'factors': factors,
        'breakdown': {'sq9_score': sq9_score, 'time_score': time_score, 
                      'angle_score': angle_score, 'converge_score': converge_score}
    }

# =========================================================================
# GANN TURN DIRECTION PREDICTOR
# =========================================================================

@dataclass
class GannTurnPrediction:
    """Gann Turn Direction Prediction with clear options guidance."""
    symbol: str
    turn_type: TurnType
    timeframe: Timeframe
    options_action: OptionsAction
    direction: str
    confidence: float
    support_level: float
    resistance_level: float
    entry_price: float
    stop_loss: float
    target_1: float
    target_2: float
    expiry_suggestion: str
    strike_suggestion: str
    rationale: str
    gann_confluence_score: int
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    
    def to_dict(self) -> dict:
        action_str = self.options_action.value
        if "BUY" in action_str or "SELL" in action_str:
            action_str = action_str.replace("CALLS", f"{self.symbol} CALLS").replace("PUTS", f"{self.symbol} PUTS")
        return {
            "Timestamp": self.timestamp,
            "Symbol": self.symbol,
            "Timeframe": self.timeframe.value,
            "TurnType": self.turn_type.value,
            "OptionsAction": action_str,
            "Direction": self.direction,
            "Confidence": round(self.confidence, 1),
            "GannConfluence": self.gann_confluence_score,
            "SupportLevel": round(self.support_level, 2),
            "ResistanceLevel": round(self.resistance_level, 2),
            "EntryPrice": round(self.entry_price, 2),
            "StopLoss": round(self.stop_loss, 2),
            "Target1": round(self.target_1, 2),
            "Target2": round(self.target_2, 2),
            "ExpirySuggestion": self.expiry_suggestion,
            "StrikeSuggestion": self.strike_suggestion,
            "Rationale": self.rationale,
        }
    
    def __str__(self) -> str:
        action = self.options_action.value.replace("CALLS", f"{self.symbol} CALLS").replace("PUTS", f"{self.symbol} PUTS")
        return (
            f"[{self.timeframe.value}] {self.symbol} {self.turn_type.value} ‚Üí {action}\n"
            f"  Direction: {self.direction} | Confidence: {self.confidence:.1f}% | Gann Score: {self.gann_confluence_score}/100\n"
            f"  Entry: ${self.entry_price:.2f} | Stop: ${self.stop_loss:.2f}\n"
            f"  Target 1: ${self.target_1:.2f} | Target 2: ${self.target_2:.2f}\n"
            f"  Strike: {self.strike_suggestion} | Expiry: {self.expiry_suggestion}\n"
            f"  Rationale: {self.rationale}"
        )


def calculate_atr_from_df(df: pd.DataFrame, period: int = 14) -> float:
    """Calculate ATR from DataFrame."""
    if len(df) < period + 1:
        return df['high'].iloc[-1] - df['low'].iloc[-1]
    
    high, low, close = df['high'].values, df['low'].values, df['close'].values
    tr_list = [max(high[i] - low[i], abs(high[i] - close[i-1]), abs(low[i] - close[i-1])) for i in range(1, len(df))]
    
    return sum(tr_list[-period:]) / period if len(tr_list) >= period else sum(tr_list) / len(tr_list)


def get_expiry_suggestion(timeframe: Timeframe) -> str:
    """Get appropriate options expiry based on timeframe."""
    return {
        Timeframe.MIN_1: "0-1 DTE (Same day)",
        Timeframe.MIN_5: "0-1 DTE (Same day)",
        Timeframe.MIN_15: "1-3 DTE (This week)",
        Timeframe.MIN_30: "3-5 DTE (This week)",
        Timeframe.HOURLY: "5-7 DTE (This/Next week)",
        Timeframe.DAILY: "7-14 DTE (1-2 weeks)",
        Timeframe.WEEKLY: "14-30 DTE (2-4 weeks)",
        Timeframe.MONTHLY: "30-60 DTE (1-2 months)",
    }.get(timeframe, "7-14 DTE")


def predict_gann_turn_direction(df: pd.DataFrame, symbol: str, 
                                 timeframe: Timeframe = Timeframe.DAILY, lookback: int = 50) -> GannTurnPrediction:
    """Predict whether upcoming turn is PULLBACK or BREAKDOWN using full Gann analysis."""
    if len(df) < lookback:
        return GannTurnPrediction(
            symbol=symbol, turn_type=TurnType.NO_TURN, timeframe=timeframe,
            options_action=OptionsAction.NO_ACTION, direction="NEUTRAL", confidence=0,
            support_level=0, resistance_level=0, entry_price=0, stop_loss=0,
            target_1=0, target_2=0, expiry_suggestion="N/A", strike_suggestion="N/A",
            rationale=f"Insufficient data for {timeframe.value} analysis", gann_confluence_score=0
        )
    
    recent = df.tail(lookback).copy()
    current_price = recent['close'].iloc[-1]
    
    # Gann Square of 9 levels
    sq9 = GannSquareOf9.calculate_levels(current_price, increments=5)
    nearest_support = sq9['support'][0]['price'] if sq9['support'] else current_price * 0.95
    nearest_resistance = sq9['resistance'][0]['price'] if sq9['resistance'] else current_price * 1.05
    
    # Find pivot
    high_idx, low_idx = recent['high'].idxmax(), recent['low'].idxmin()
    pivot_high, pivot_low = recent['high'].max(), recent['low'].min()
    
    if high_idx > low_idx:
        pivot_date, pivot_price, is_pivot_low = high_idx, pivot_high, False
    else:
        pivot_date, pivot_price, is_pivot_low = low_idx, pivot_low, True
    
    current_date = datetime.now()
    pivot_dt = pivot_date.to_pydatetime() if hasattr(pivot_date, 'to_pydatetime') else current_date - timedelta(days=20)
    
    cycle_status = GannTimeCycles.calculate_cycle_position(pivot_dt, current_date)
    angle_levels = GannAngles.calculate_angle_levels(pivot_price, pivot_dt, current_date, is_pivot_low)
    angle_position = GannAngles.get_price_position(current_price, angle_levels)
    confluence = calculate_gann_confluence(current_price, sq9, cycle_status, angle_position)
    
    atr = calculate_atr_from_df(recent, 14)
    
    # Volume analysis
    avg_volume = recent['volume'].rolling(20).mean().iloc[-1]
    recent_volume = recent['volume'].iloc[-5:].mean()
    volume_expanding = recent_volume > avg_volume * 1.2
    volume_contracting = recent_volume < avg_volume * 0.8
    
    # Trend analysis
    sma_20 = recent['close'].rolling(20).mean().iloc[-1]
    sma_50 = recent['close'].rolling(min(50, len(recent))).mean().iloc[-1]
    trend_up = current_price > sma_20 > sma_50
    trend_down = current_price < sma_20 < sma_50
    
    near_support = abs(current_price - nearest_support) < atr * 0.5
    near_resistance = abs(current_price - nearest_resistance) < atr * 0.5
    below_support = current_price < nearest_support - atr * 0.25
    above_resistance = current_price > nearest_resistance + atr * 0.25
    
    turn_type, options_action, direction = TurnType.NO_TURN, OptionsAction.NO_ACTION, "NEUTRAL"
    confidence, rationale = 50.0 + confluence['score'] * 0.3, ""
    
    if below_support and volume_expanding:
        turn_type, options_action, direction = TurnType.BREAKDOWN, OptionsAction.BUY_PUTS, "DOWN"
        confidence = 75 + (15 if trend_down else 0) + confluence['score'] * 0.1
        rationale = f"BREAKDOWN: Price ${current_price:.2f} broke below SQ9 support ${nearest_support:.2f} with expanding volume. Gann: {confluence['score']}/100."
    elif above_resistance and volume_expanding:
        turn_type, options_action, direction = TurnType.BREAKOUT, OptionsAction.BUY_CALLS, "UP"
        confidence = 75 + (15 if trend_up else 0) + confluence['score'] * 0.1
        rationale = f"BREAKOUT: Price ${current_price:.2f} broke above SQ9 resistance ${nearest_resistance:.2f} with expanding volume. Gann: {confluence['score']}/100."
    elif trend_up and near_support and volume_contracting:
        turn_type, options_action, direction = TurnType.PULLBACK, OptionsAction.BUY_CALLS, "UP"
        confidence = 70 + (10 if confluence['score'] >= 50 else 0)
        rationale = f"PULLBACK in UPTREND: Price ${current_price:.2f} at SQ9 support ${nearest_support:.2f}. Support expected to HOLD. Gann: {confluence['score']}/100."
    elif trend_down and near_resistance and volume_contracting:
        turn_type, options_action, direction = TurnType.PULLBACK, OptionsAction.BUY_PUTS, "DOWN"
        confidence = 70 + (10 if confluence['score'] >= 50 else 0)
        rationale = f"PULLBACK in DOWNTREND: Price ${current_price:.2f} at SQ9 resistance ${nearest_resistance:.2f}. Resistance expected to HOLD. Gann: {confluence['score']}/100."
    elif near_support and not below_support and volume_expanding and not trend_down:
        turn_type, options_action, direction = TurnType.BOUNCE, OptionsAction.BUY_CALLS, "UP"
        confidence = 65 + (15 if confluence['score'] >= 50 else 5)
        rationale = f"BOUNCE: Price ${current_price:.2f} testing SQ9 support ${nearest_support:.2f} with volume. Gann: {confluence['score']}/100."
    else:
        rationale = f"NO CLEAR TURN: Price ${current_price:.2f} between SQ9 levels. Gann: {confluence['score']}/100. Wait."
    
    confidence = min(confidence, 100)
    
    if direction == "UP":
        entry_price, stop_loss = current_price, nearest_support - atr * 0.5
        target_1, target_2 = nearest_resistance, sq9['resistance'][1]['price'] if len(sq9['resistance']) > 1 else nearest_resistance * 1.02
    elif direction == "DOWN":
        entry_price, stop_loss = current_price, nearest_resistance + atr * 0.5
        target_1, target_2 = nearest_support, sq9['support'][1]['price'] if len(sq9['support']) > 1 else nearest_support * 0.98
    else:
        entry_price = stop_loss = target_1 = target_2 = current_price
    
    strike_suggestion = f"ATM or 1-2 strikes ITM (${round(current_price)})" if direction != "NEUTRAL" else "Wait for clear signal"
    expiry_suggestion = get_expiry_suggestion(timeframe) if direction != "NEUTRAL" else "N/A"
    
    return GannTurnPrediction(
        symbol=symbol, turn_type=turn_type, timeframe=timeframe, options_action=options_action,
        direction=direction, confidence=confidence, support_level=nearest_support,
        resistance_level=nearest_resistance, entry_price=entry_price, stop_loss=stop_loss,
        target_1=target_1, target_2=target_2, expiry_suggestion=expiry_suggestion,
        strike_suggestion=strike_suggestion, rationale=rationale, gann_confluence_score=confluence['score']
    )


def analyze_multiple_timeframes(df: pd.DataFrame, symbol: str) -> List[GannTurnPrediction]:
    """Analyze multiple timeframes."""
    predictions = [predict_gann_turn_direction(df, symbol, Timeframe.DAILY, lookback=50)]
    if len(df) >= 10:
        predictions.append(predict_gann_turn_direction(df.tail(20), symbol, Timeframe.MIN_15, lookback=15))
    if len(df) >= 100:
        predictions.append(predict_gann_turn_direction(df, symbol, Timeframe.WEEKLY, lookback=100))
    return predictions


def write_gann_turn_predictions(predictions: List[GannTurnPrediction], output_dir: pathlib.Path) -> None:
    """Write Gann turn predictions to CSV."""
    path = output_dir / "gann_turn_predictions.csv"
    fieldnames = ["Timestamp", "Symbol", "Timeframe", "TurnType", "OptionsAction", "Direction",
                  "Confidence", "GannConfluence", "SupportLevel", "ResistanceLevel", "EntryPrice",
                  "StopLoss", "Target1", "Target2", "ExpirySuggestion", "StrikeSuggestion", "Rationale"]
    
    with path.open('w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for pred in predictions:
            writer.writerow(pred.to_dict())
    logger.info(f"Wrote {len(predictions)} predictions to {path}")


def write_gann_analysis_json(symbol: str, current_price: float, sq9_levels: Dict, 
                              cycle_status: Dict, angle_levels: Dict, confluence: Dict, output_dir: pathlib.Path) -> None:
    """Write Gann analysis to JSON."""
    analysis = {
        'symbol': symbol, 'timestamp': datetime.now().isoformat(), 'current_price': current_price,
        'square_of_9': sq9_levels, 'time_cycles': cycle_status, 'gann_angles': angle_levels,
        'confluence': confluence, 'seasonal': GannTimeCycles.days_to_next_seasonal(datetime.now())
    }
    path = output_dir / f"gann_analysis_{symbol}.json"
    path.write_text(json.dumps(analysis, indent=2, default=str))
    logger.info(f"Wrote Gann analysis to {path}")


# =========================================================================
# LOGGING & DATA STRUCTURES
# =========================================================================

def setup_logging(log_dir: str = "logs", level: int = logging.INFO) -> logging.Logger:
    """Setup logging."""
    log_path = pathlib.Path(log_dir)
    log_path.mkdir(parents=True, exist_ok=True)
    
    logger = logging.getLogger("confluence_agent")
    logger.setLevel(level)
    if logger.hasHandlers():
        logger.handlers.clear()
    
    formatter = logging.Formatter('%(asctime)s | %(levelname)-8s | %(funcName)-30s | %(message)s', '%Y-%m-%d %H:%M:%S')
    
    fh = logging.FileHandler(log_path / "agent.log")
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    
    ch = logging.StreamHandler()
    ch.setLevel(level)
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    
    return logger

logger = setup_logging()

@dataclass
class Bar:
    """Daily OHLCV bar."""
    d: str
    open_: float
    high: float
    low: float
    close: float
    volume: float
    atr: Optional[float] = None
    fast_sma: Optional[float] = None
    slow_sma: Optional[float] = None
    bias: Optional[str] = None
    geo_level: Optional[float] = None
    phi_level: Optional[float] = None
    price_confluence: int = 0
    time_confluence: int = 0

# Config
DATA_DIR = pathlib.Path("data")
REPORT_DIR = pathlib.Path("reports")
DATA_DIR.mkdir(parents=True, exist_ok=True)
REPORT_DIR.mkdir(parents=True, exist_ok=True)

START_DATE = "2022-11-01"
ATR_LENGTH = 14
FAST_SMA_LEN = 10
SLOW_SMA_LEN = 20
PRICE_TOL_PCT = 0.008
ENTRY_BAND_ATR = 0.5
STOP_ATR = 1.5

MAX_RETRIES = 3
RETRY_DELAY = 2
REQUEST_TIMEOUT = 30


def fetch_tiingo_daily_with_retry(symbol: str, start_date: str, max_retries: int = MAX_RETRIES) -> List[Bar]:
    """Fetch daily OHLCV from Tiingo."""
    token = os.getenv("TIINGO_TOKEN")
    if not token:
        logger.error("TIINGO_TOKEN not set!")
        return []
    
    url = f"https://api.tiingo.com/tiingo/daily/{symbol}/prices?startDate={start_date}&token={token}"
    
    for attempt in range(1, max_retries + 1):
        try:
            logger.info(f"[{attempt}/{max_retries}] Fetching {symbol}...")
            req = urllib.request.Request(url)
            req.add_header('User-Agent', 'ConfluenceAgent/1.0')
            
            with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as resp:
                data = json.loads(resp.read().decode('utf-8'))
                if not isinstance(data, list):
                    return []
                
                logger.info(f"Got {len(data)} bars for {symbol}")
                return [Bar(d=i['date'], open_=i['open'], high=i['high'], low=i['low'], 
                           close=i['close'], volume=i['volume']) for i in data]
        except Exception as e:
            logger.warning(f"Error: {e}")
            if attempt < max_retries:
                time.sleep(RETRY_DELAY * (2 ** (attempt - 1)))
    return []


def compute_atr(bars: List[Bar], length: int = 14) -> None:
    """Compute ATR."""
    for i, bar in enumerate(bars):
        if i < length:
            bar.atr = None
            continue
        trs = []
        for j in range(i - length + 1, i + 1):
            tr = max(bars[j].high - bars[j].low, 
                    abs(bars[j].high - bars[j-1].close) if j > 0 else 0,
                    abs(bars[j].low - bars[j-1].close) if j > 0 else 0)
            trs.append(tr)
        bar.atr = sum(trs) / len(trs)


def compute_sma(bars: List[Bar], length: int) -> List[Optional[float]]:
    """Compute SMA."""
    return [None if i < length - 1 else sum(bars[j].close for j in range(i - length + 1, i + 1)) / length 
            for i, _ in enumerate(bars)]


def compute_bias(bars: List[Bar]) -> None:
    """Compute bias."""
    for bar in bars:
        if bar.fast_sma and bar.slow_sma:
            bar.bias = "CALL" if bar.fast_sma > bar.slow_sma else "PUT"


def tag_confluence(bars: List[Bar], price_tol: float = 0.008) -> None:
    """Tag confluence."""
    for i, bar in enumerate(bars):
        bar.price_confluence = bar.time_confluence = 0
        if bar.atr is None or bar.bias is None or i <= 10:
            continue
        recent_high = max(bars[j].high for j in range(max(0, i-10), i))
        recent_low = min(bars[j].low for j in range(max(0, i-10), i))
        bar.geo_level = (recent_high + recent_low) / 2
        bar.phi_level = recent_high * 0.618
        if bar.geo_level and abs(bar.close - bar.geo_level) < bar.atr * price_tol:
            bar.price_confluence = 1


def write_symbol_csv(symbol: str, bars: List[Bar]) -> None:
    """Write CSV."""
    path = DATA_DIR / f"{symbol}.csv"
    with path.open('w', newline='') as f:
        w = csv.DictWriter(f, fieldnames=['Date','Open','High','Low','Close','Volume','ATR','FastSMA','SlowSMA','Bias','GeoLevel','PhiLevel','PriceConfluence','TimeConfluence'])
        w.writeheader()
        for b in bars:
            w.writerow({'Date':b.d,'Open':round(b.open_,2),'High':round(b.high,2),'Low':round(b.low,2),
                       'Close':round(b.close,2),'Volume':int(b.volume),'ATR':round(b.atr,2) if b.atr else '',
                       'FastSMA':round(b.fast_sma,2) if b.fast_sma else '','SlowSMA':round(b.slow_sma,2) if b.slow_sma else '',
                       'Bias':b.bias or '','GeoLevel':round(b.geo_level,2) if b.geo_level else '',
                       'PhiLevel':round(b.phi_level,2) if b.phi_level else '','PriceConfluence':b.price_confluence,'TimeConfluence':b.time_confluence})
    logger.info(f"Wrote {len(bars)} bars to {path}")


def build_confluence_trades(bars: List[Bar], symbol: str) -> List[dict]:
    """Build trades."""
    trades = []
    for bar in bars:
        if not bar.bias or not (bar.price_confluence or bar.time_confluence) or bar.atr is None:
            continue
        entry_band = bar.atr * ENTRY_BAND_ATR
        stop_dist = bar.atr * STOP_ATR
        if bar.bias == "CALL":
            stop, t1, t2 = bar.close - stop_dist, bar.close + stop_dist*2, bar.close + stop_dist*3
        else:
            stop, t1, t2 = bar.close + stop_dist, bar.close - stop_dist*2, bar.close - stop_dist*3
        trades.append({'Symbol':symbol,'Signal':bar.bias,'EntryDate':bar.d,'ExitDate':'','EntryPrice':round(bar.close,2),
                      'ExitPrice':'','PNL':'','EntryLow':round(bar.close-entry_band,2),'EntryHigh':round(bar.close+entry_band,2),
                      'Stop':round(stop,2),'Target1':round(t1,2),'Target2':round(t2,2),'ExpiryDate':'','Status':f'BASE ({symbol})'})
    return trades


def write_portfolio_confluence(trades: List[dict]) -> None:
    """Write portfolio."""
    path = REPORT_DIR / "portfolio_confluence.csv"
    with path.open('w', newline='') as f:
        w = csv.DictWriter(f, fieldnames=['Symbol','Signal','EntryDate','ExitDate','EntryPrice','ExitPrice','PNL','EntryLow','EntryHigh','Stop','Target1','Target2','ExpiryDate','Status'])
        w.writeheader()
        w.writerows(trades)
    logger.info(f"Wrote {len(trades)} trades")


def bars_to_dataframe(bars: List[Bar]) -> pd.DataFrame:
    """Convert to DataFrame."""
    if not bars:
        return pd.DataFrame()
    return pd.DataFrame({'open':[b.open_ for b in bars],'high':[b.high for b in bars],'low':[b.low for b in bars],
                        'close':[b.close for b in bars],'volume':[b.volume for b in bars]},
                       index=pd.to_datetime([b.d for b in bars]))


# =========================================================================
# MAIN
# =========================================================================

def main() -> None:
    """Main agent run."""
    symbol = ACTIVE_SYMBOL
    
    logger.info("=" * 80)
    logger.info(f"CONFLUENCE AGENT - ANALYZING {symbol}")
    logger.info(f"Gann: Square of 9, Time Cycles, Angles, Turn Predictor")
    logger.info("=" * 80)
    
    bars = fetch_tiingo_daily_with_retry(symbol, START_DATE)
    if not bars:
        logger.error(f"Failed to fetch {symbol}")
        return
    
    logger.info(f"Processing {len(bars)} bars for {symbol}")
    
    compute_atr(bars, ATR_LENGTH)
    fast, slow = compute_sma(bars, FAST_SMA_LEN), compute_sma(bars, SLOW_SMA_LEN)
    for b, f, s in zip(bars, fast, slow):
        b.fast_sma, b.slow_sma = f, s
    compute_bias(bars)
    tag_confluence(bars, PRICE_TOL_PCT)
    
    write_symbol_csv(symbol, bars)
    trades = build_confluence_trades(bars, symbol)
    write_portfolio_confluence(trades)
    
    df = bars_to_dataframe(bars)
    current_price = df['close'].iloc[-1]
    
    # GANN ANALYSIS
    logger.info("\n" + "=" * 80)
    logger.info(f"GANN ANALYSIS FOR {symbol} @ ${current_price:.2f}")
    logger.info("=" * 80)
    
    sq9 = GannSquareOf9.calculate_levels(current_price, increments=5)
    logger.info(f"\nüìê SQUARE OF 9: R={[f'${r[\"price\"]}' for r in sq9['resistance'][:3]]} | S={[f'${s[\"price\"]}' for s in sq9['support'][:3]]}")
    
    pivot_date = datetime.now() - timedelta(days=30)
    cycle_status = GannTimeCycles.calculate_cycle_position(pivot_date, datetime.now())
    logger.info(f"\n‚è∞ TIME CYCLES:")
    for name, data in cycle_status['cycles'].items():
        logger.info(f"  {name}: Day {data['day']}/{data['of']} ({data['progress_pct']}%) {'‚ö†Ô∏è TURN' if data['in_turn_zone'] else ''}")
    
    angle_levels = GannAngles.calculate_angle_levels(current_price * 0.95, pivot_date, datetime.now(), True)
    angle_position = GannAngles.get_price_position(current_price, angle_levels)
    logger.info(f"\nüìä ANGLES: Nearest={angle_position['nearest_angle']} @ ${angle_position['nearest_price']:.2f}")
    
    confluence = calculate_gann_confluence(current_price, sq9, cycle_status, angle_position)
    logger.info(f"\nüéØ CONFLUENCE: {confluence['score']}/100 - {confluence['zone']}")
    
    write_gann_analysis_json(symbol, current_price, sq9, cycle_status, angle_levels, confluence, DATA_DIR)
    
    # PREDICTIONS
    logger.info("\n" + "=" * 80)
    logger.info(f"TURN PREDICTIONS FOR {symbol}")
    logger.info("=" * 80)
    
    predictions = analyze_multiple_timeframes(df, symbol)
    for pred in predictions:
        logger.info(f"\n{pred}")
    
    write_gann_turn_predictions(predictions, REPORT_DIR)
    
    logger.info("\n" + "=" * 80)
    logger.info("SUMMARY")
    logger.info("=" * 80)
    for pred in predictions:
        action = pred.options_action.value.replace("CALLS", f"{symbol} CALLS").replace("PUTS", f"{symbol} PUTS")
        logger.info(f"[{pred.timeframe.value}] {pred.turn_type.value} ‚Üí {action} | {pred.confidence:.1f}% | Gann: {pred.gann_confluence_score}/100")
    
    logger.info("\nDONE")

if __name__ == "__main__":
    main()
