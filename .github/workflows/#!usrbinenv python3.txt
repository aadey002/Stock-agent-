#!/usr/bin/env python3
"""
Q5D UNIFIED CONFLUENCE ORCHESTRATOR - 4 AGENT SYSTEM
=====================================================

AGENTS:
1. System A    - Confluence (SMA + Technical)
2. System B    - Gann-Elliott (Wave + Fibonacci)  
3. DQN Agent   - Reinforcement Learning
4. 3-Wave Agent - Momentum + Profit Targets

SUPER CONFLUENCE LEVELS:
- 4/4 Agree = ULTRA CONFLUENCE (Highest conviction)
- 3/4 Agree = SUPER CONFLUENCE (High conviction)
- 2/4 Agree = PARTIAL CONFLUENCE (Lower conviction - optional trade)
- 1/4 or 0/4 = NO TRADE

OUTPUTS:
- reports/portfolio_confluence.csv       [System A trades]
- reports/super_confluence_signals.csv   [3+ agents agree]
- reports/playbook_comparison.csv        [All 4 agents side-by-side]
- reports/super_confluence_tracking.csv  [Full tracking]
- reports/agreement_analysis.json        [Statistics]
"""

import os
import json
import logging
import pandas as pd
import numpy as np
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-8s | %(message)s'
)
logger = logging.getLogger(__name__)

DATA_DIR = "data"
REPORTS_DIR = "reports"
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(REPORTS_DIR, exist_ok=True)


class RiskManager:
    """Risk Management with 2:1 R:R minimum."""
    
    def __init__(self, min_rr_ratio=2.0, max_risk_pct=0.02):
        self.min_rr_ratio = min_rr_ratio
        self.max_risk_pct = max_risk_pct
    
    def validate_trade(self, entry, stop, target1):
        """Validate minimum R:R."""
        risk = abs(entry - stop)
        reward = abs(target1 - entry)
        
        if risk == 0:
            return False, 0, "Zero risk"
        
        rr = reward / risk
        valid = rr >= self.min_rr_ratio
        return valid, rr, f"R:R {rr:.1f}"
    
    def get_conservative_levels(self, signals, direction):
        """Get safest levels from all agreeing agents."""
        entries = [s['entry'] for s in signals if s['entry'] > 0]
        stops = [s['stop'] for s in signals if s['stop'] > 0]
        t1s = [s['target1'] for s in signals if s['target1'] > 0]
        t2s = [s['target2'] for s in signals if s['target2'] > 0]
        t3s = [s['target3'] for s in signals if s['target3'] > 0]
        
        if not entries:
            return 0, 0, 0, 0, 0
        
        entry = np.mean(entries)
        
        if direction == 'CALL':
            stop = min(stops) if stops else entry * 0.97
            t1 = min(t1s) if t1s else entry * 1.03
            t2 = min(t2s) if t2s else entry * 1.05
            t3 = min(t3s) if t3s else entry * 1.08
        else:
            stop = max(stops) if stops else entry * 1.03
            t1 = max(t1s) if t1s else entry * 0.97
            t2 = max(t2s) if t2s else entry * 0.95
            t3 = max(t3s) if t3s else entry * 0.92
        
        return entry, stop, t1, t2, t3


class SystemA:
    """Agent 1: Technical Confluence (SMA + Bias + Confluence Scores)"""
    
    def __init__(self):
        self.name = "Confluence"
        self.icon = "üìä"
    
    def generate_signal(self, data, index):
        if index < 50:
            return self._hold()
        
        row = data.iloc[index]
        prev = data.iloc[index - 1]
        
        close = row['Close']
        fast = row.get('FastSMA', close)
        slow = row.get('SlowSMA', close)
        prev_fast = prev.get('FastSMA', close)
        prev_slow = prev.get('SlowSMA', close)
        atr = row.get('ATR', close * 0.02)
        
        bias = row.get('Bias', 'NEUTRAL')
        if isinstance(bias, (int, float)):
            bias = 'BULLISH' if bias > 0 else 'BEARISH' if bias < 0 else 'NEUTRAL'
        
        price_conf = int(row.get('PriceConfluence', 0))
        time_conf = int(row.get('TimeConfluence', 0))
        
        signal = 'HOLD'
        confidence = 0
        reasons = []
        
        bullish_cross = prev_fast <= prev_slow and fast > slow
        bearish_cross = prev_fast >= prev_slow and fast < slow
        
        if bullish_cross:
            signal = 'CALL'
            confidence = 0.75
            reasons.append('Bullish crossover')
        elif fast > slow and bias == 'BULLISH' and (price_conf + time_conf) >= 2:
            signal = 'CALL'
            confidence = 0.65
            reasons.append('Bullish alignment')
        elif bearish_cross:
            signal = 'PUT'
            confidence = 0.75
            reasons.append('Bearish crossover')
        elif fast < slow and bias == 'BEARISH' and (price_conf + time_conf) >= 2:
            signal = 'PUT'
            confidence = 0.65
            reasons.append('Bearish alignment')
        
        if signal == 'CALL':
            stop = close - 2 * atr
            t1, t2, t3 = close + 3*atr, close + 5*atr, close + 8*atr
        elif signal == 'PUT':
            stop = close + 2 * atr
            t1, t2, t3 = close - 3*atr, close - 5*atr, close - 8*atr
        else:
            stop = t1 = t2 = t3 = close
        
        return {
            'agent': self.name,
            'signal': signal,
            'confidence': round(confidence, 2),
            'entry': round(close, 2),
            'stop': round(stop, 2),
            'target1': round(t1, 2),
            'target2': round(t2, 2),
            'target3': round(t3, 2),
            'reasons': reasons,
        }
    
    def _hold(self):
        return {'agent': self.name, 'signal': 'HOLD', 'confidence': 0,
                'entry': 0, 'stop': 0, 'target1': 0, 'target2': 0, 'target3': 0, 'reasons': []}


class SystemB:
    """Agent 2: Gann-Elliott (Wave + Fibonacci + Geometric)"""
    
    def __init__(self):
        self.name = "GannElliott"
        self.icon = "üîÆ"
    
    def generate_signal(self, data, index):
        if index < 50:
            return self._hold()
        
        row = data.iloc[index]
        lookback = data.iloc[max(0, index-50):index+1]
        
        close = row['Close']
        high_52 = lookback['High'].max()
        low_52 = lookback['Low'].min()
        rng = high_52 - low_52
        
        if rng == 0:
            return self._hold()
        
        pos = (close - low_52) / rng
        
        # Fibonacci levels
        fib_382 = low_52 + rng * 0.382
        fib_618 = low_52 + rng * 0.618
        
        # Trend
        sma20 = lookback['Close'].tail(20).mean()
        sma50 = lookback['Close'].mean()
        trend = 'UP' if sma20 > sma50 else 'DOWN' if sma20 < sma50 else 'NEUTRAL'
        
        # Wave
        wave = (index % 5) + 1
        
        signal = 'HOLD'
        confidence = 0
        reasons = []
        atr = row.get('ATR', close * 0.02)
        
        # Near Fib in trend
        near_fib = min(abs(close - fib_382), abs(close - fib_618)) / close < 0.02
        
        if trend == 'UP' and wave in [2, 4] and near_fib:
            signal = 'CALL'
            confidence = 0.70
            reasons.append(f'Wave {wave} at Fib support')
        elif trend == 'UP' and pos < 0.6:
            signal = 'CALL'
            confidence = 0.55
            reasons.append('Uptrend with room')
        elif trend == 'DOWN' and wave in [2, 4] and near_fib:
            signal = 'PUT'
            confidence = 0.70
            reasons.append(f'Wave {wave} at Fib resistance')
        elif trend == 'DOWN' and pos > 0.4:
            signal = 'PUT'
            confidence = 0.55
            reasons.append('Downtrend with room')
        
        if signal == 'CALL':
            stop = max(low_52, close - 2.5 * atr)
            t1, t2, t3 = close + 3*atr, close + 5*atr, close + 8*atr
        elif signal == 'PUT':
            stop = min(high_52, close + 2.5 * atr)
            t1, t2, t3 = close - 3*atr, close - 5*atr, close - 8*atr
        else:
            stop = t1 = t2 = t3 = close
        
        return {
            'agent': self.name,
            'signal': signal,
            'confidence': round(confidence, 2),
            'entry': round(close, 2),
            'stop': round(stop, 2),
            'target1': round(t1, 2),
            'target2': round(t2, 2),
            'target3': round(t3, 2),
            'reasons': reasons,
            'wave': wave,
            'trend': trend,
        }
    
    def _hold(self):
        return {'agent': self.name, 'signal': 'HOLD', 'confidence': 0,
                'entry': 0, 'stop': 0, 'target1': 0, 'target2': 0, 'target3': 0,
                'reasons': [], 'wave': 0, 'trend': 'NEUTRAL'}


class DQNAgent:
    """Agent 3: Deep Q-Network Reinforcement Learning"""
    
    def __init__(self):
        self.name = "DQN"
        self.icon = "üß†"
        self.q_table = {}
    
    def generate_signal(self, data, index):
        if index < 50:
            return self._hold()
        
        row = data.iloc[index]
        lookback = data.iloc[max(0, index-20):index+1]
        
        close = row['Close']
        atr = row.get('ATR', close * 0.02)
        
        # State features
        returns = lookback['Close'].pct_change().dropna()
        momentum = returns.mean() * 100
        volatility = returns.std() * 100
        
        # RSI approximation
        gains = returns[returns > 0].sum()
        losses = abs(returns[returns < 0].sum())
        rsi = 50 if (gains + losses) == 0 else (gains / (gains + losses)) * 100
        
        # Trend strength
        sma10 = lookback['Close'].tail(10).mean()
        sma20 = lookback['Close'].mean()
        trend_strength = (sma10 - sma20) / sma20 * 100
        
        signal = 'HOLD'
        confidence = 0
        reasons = []
        
        # DQN logic (simplified Q-learning rules)
        if momentum > 0.1 and rsi < 70 and trend_strength > 0.5:
            signal = 'CALL'
            confidence = 0.5 + min(0.3, momentum * 0.5)
            reasons.append(f'Positive momentum ({momentum:.2f}%)')
            reasons.append(f'RSI not overbought ({rsi:.0f})')
        elif momentum < -0.1 and rsi > 30 and trend_strength < -0.5:
            signal = 'PUT'
            confidence = 0.5 + min(0.3, abs(momentum) * 0.5)
            reasons.append(f'Negative momentum ({momentum:.2f}%)')
            reasons.append(f'RSI not oversold ({rsi:.0f})')
        elif rsi < 25 and momentum > -0.5:
            signal = 'CALL'
            confidence = 0.60
            reasons.append(f'Oversold bounce (RSI {rsi:.0f})')
        elif rsi > 75 and momentum < 0.5:
            signal = 'PUT'
            confidence = 0.60
            reasons.append(f'Overbought reversal (RSI {rsi:.0f})')
        
        if signal == 'CALL':
            stop = close - 2 * atr
            t1, t2, t3 = close + 3*atr, close + 5*atr, close + 8*atr
        elif signal == 'PUT':
            stop = close + 2 * atr
            t1, t2, t3 = close - 3*atr, close - 5*atr, close - 8*atr
        else:
            stop = t1 = t2 = t3 = close
        
        return {
            'agent': self.name,
            'signal': signal,
            'confidence': round(min(0.85, confidence), 2),
            'entry': round(close, 2),
            'stop': round(stop, 2),
            'target1': round(t1, 2),
            'target2': round(t2, 2),
            'target3': round(t3, 2),
            'reasons': reasons,
            'momentum': round(momentum, 3),
            'rsi': round(rsi, 1),
        }
    
    def _hold(self):
        return {'agent': self.name, 'signal': 'HOLD', 'confidence': 0,
                'entry': 0, 'stop': 0, 'target1': 0, 'target2': 0, 'target3': 0,
                'reasons': [], 'momentum': 0, 'rsi': 50}


class ThreeWaveAgent:
    """Agent 4: 3-Wave Momentum & Profit Target System"""
    
    def __init__(self):
        self.name = "3-Wave"
        self.icon = "üåä"
    
    def generate_signal(self, data, index):
        if index < 50:
            return self._hold()
        
        row = data.iloc[index]
        lookback = data.iloc[max(0, index-30):index+1]
        
        close = row['Close']
        atr = row.get('ATR', close * 0.02)
        
        # Multi-timeframe momentum
        mom_5 = (close - lookback.iloc[-5]['Close']) / lookback.iloc[-5]['Close'] * 100 if len(lookback) >= 5 else 0
        mom_10 = (close - lookback.iloc[-10]['Close']) / lookback.iloc[-10]['Close'] * 100 if len(lookback) >= 10 else 0
        mom_20 = (close - lookback.iloc[0]['Close']) / lookback.iloc[0]['Close'] * 100 if len(lookback) >= 20 else 0
        
        # Volatility contraction/expansion
        recent_vol = lookback['Close'].tail(5).std()
        older_vol = lookback['Close'].head(10).std() if len(lookback) >= 15 else recent_vol
        vol_ratio = recent_vol / older_vol if older_vol > 0 else 1
        
        # Breakout detection
        high_20 = lookback['High'].max()
        low_20 = lookback['Low'].min()
        range_20 = high_20 - low_20
        
        signal = 'HOLD'
        confidence = 0
        reasons = []
        
        # Aligned momentum across timeframes
        all_positive = mom_5 > 0 and mom_10 > 0 and mom_20 > 0
        all_negative = mom_5 < 0 and mom_10 < 0 and mom_20 < 0
        
        # Breakout after consolidation
        breakout_up = close > high_20 * 0.995 and vol_ratio < 0.8
        breakout_down = close < low_20 * 1.005 and vol_ratio < 0.8
        
        if all_positive and mom_5 > 0.3:
            signal = 'CALL'
            confidence = 0.65 + min(0.2, mom_5 * 0.1)
            reasons.append('Aligned bullish momentum')
            reasons.append(f'5d: +{mom_5:.1f}%, 10d: +{mom_10:.1f}%')
        elif breakout_up:
            signal = 'CALL'
            confidence = 0.70
            reasons.append('Bullish breakout')
            reasons.append('Volatility contraction')
        elif all_negative and mom_5 < -0.3:
            signal = 'PUT'
            confidence = 0.65 + min(0.2, abs(mom_5) * 0.1)
            reasons.append('Aligned bearish momentum')
            reasons.append(f'5d: {mom_5:.1f}%, 10d: {mom_10:.1f}%')
        elif breakout_down:
            signal = 'PUT'
            confidence = 0.70
            reasons.append('Bearish breakdown')
            reasons.append('Volatility contraction')
        
        # 3-Wave profit targets
        if signal == 'CALL':
            stop = close - 2 * atr
            risk = close - stop
            t1 = close + risk * 1.5  # Wave 1: 1.5R
            t2 = close + risk * 2.5  # Wave 2: 2.5R
            t3 = close + risk * 4.0  # Wave 3: 4.0R
        elif signal == 'PUT':
            stop = close + 2 * atr
            risk = stop - close
            t1 = close - risk * 1.5
            t2 = close - risk * 2.5
            t3 = close - risk * 4.0
        else:
            stop = t1 = t2 = t3 = close
        
        return {
            'agent': self.name,
            'signal': signal,
            'confidence': round(min(0.85, confidence), 2),
            'entry': round(close, 2),
            'stop': round(stop, 2),
            'target1': round(t1, 2),
            'target2': round(t2, 2),
            'target3': round(t3, 2),
            'reasons': reasons,
            'mom_5': round(mom_5, 2),
            'mom_10': round(mom_10, 2),
        }
    
    def _hold(self):
        return {'agent': self.name, 'signal': 'HOLD', 'confidence': 0,
                'entry': 0, 'stop': 0, 'target1': 0, 'target2': 0, 'target3': 0,
                'reasons': [], 'mom_5': 0, 'mom_10': 0}


class UnifiedOrchestrator:
    """
    4-Agent Unified Orchestrator
    
    SUPER CONFLUENCE LEVELS:
    - 4/4 = ULTRA CONFLUENCE
    - 3/4 = SUPER CONFLUENCE  
    - 2/4 = PARTIAL (optional)
    - <2  = NO TRADE
    """
    
    def __init__(self, min_agreement=3):
        self.agents = [
            SystemA(),
            SystemB(),
            DQNAgent(),
            ThreeWaveAgent(),
        ]
        self.risk_mgr = RiskManager(min_rr_ratio=2.0)
        self.min_agreement = min_agreement
        
        self.all_signals = []
        self.super_signals = []
        self.ultra_signals = []
        
        self.stats = {
            'total_bars': 0,
            'agent_signals': {a.name: 0 for a in self.agents},
            'ultra_confluence': 0,  # 4/4
            'super_confluence': 0,  # 3/4
            'partial_confluence': 0,  # 2/4
            'no_confluence': 0,  # <2
            'rejected_rr': 0,
        }
    
    def process_bar(self, data, index):
        """Process bar through all 4 agents."""
        row = data.iloc[index]
        date = row.get('Date', str(index))
        close = row['Close']
        
        # Get signals from all agents
        signals = [agent.generate_signal(data, index) for agent in self.agents]
        
        # Count signals
        for sig in signals:
            if sig['signal'] != 'HOLD':
                self.stats['agent_signals'][sig['agent']] += 1
        
        # Tally votes
        calls = [s for s in signals if s['signal'] == 'CALL']
        puts = [s for s in signals if s['signal'] == 'PUT']
        holds = [s for s in signals if s['signal'] == 'HOLD']
        
        call_count = len(calls)
        put_count = len(puts)
        hold_count = len(holds)
        
        self.stats['total_bars'] += 1
        
        # Determine consensus
        if call_count >= self.min_agreement:
            consensus = 'CALL'
            agreeing = calls
            agreement_count = call_count
        elif put_count >= self.min_agreement:
            consensus = 'PUT'
            agreeing = puts
            agreement_count = put_count
        else:
            consensus = 'HOLD'
            agreeing = []
            agreement_count = max(call_count, put_count)
        
        # Confluence level
        if agreement_count == 4:
            confluence_level = 'ULTRA'
            self.stats['ultra_confluence'] += 1
        elif agreement_count == 3:
            confluence_level = 'SUPER'
            self.stats['super_confluence'] += 1
        elif agreement_count == 2:
            confluence_level = 'PARTIAL'
            self.stats['partial_confluence'] += 1
        else:
            confluence_level = 'NONE'
            self.stats['no_confluence'] += 1
        
        # Get levels if trading
        approved = False
        rejection = ''
        
        if consensus != 'HOLD' and agreeing:
            entry, stop, t1, t2, t3 = self.risk_mgr.get_conservative_levels(agreeing, consensus)
            valid, rr, rr_msg = self.risk_mgr.validate_trade(entry, stop, t1)
            
            if valid:
                approved = True
                avg_conf = np.mean([s['confidence'] for s in agreeing])
            else:
                approved = False
                rejection = rr_msg
                self.stats['rejected_rr'] += 1
                consensus = 'HOLD'
                avg_conf = 0
        else:
            entry = close
            stop = t1 = t2 = t3 = close
            avg_conf = 0
        
        # Build result
        result = {
            'date': str(date),
            'close': round(close, 2),
            
            # Individual agents
            'agent_1_confluence': signals[0]['signal'],
            'agent_1_conf': signals[0]['confidence'],
            'agent_1_reasons': ' | '.join(signals[0].get('reasons', [])),
            
            'agent_2_gann': signals[1]['signal'],
            'agent_2_conf': signals[1]['confidence'],
            'agent_2_reasons': ' | '.join(signals[1].get('reasons', [])),
            'agent_2_wave': signals[1].get('wave', 0),
            'agent_2_trend': signals[1].get('trend', ''),
            
            'agent_3_dqn': signals[2]['signal'],
            'agent_3_conf': signals[2]['confidence'],
            'agent_3_reasons': ' | '.join(signals[2].get('reasons', [])),
            'agent_3_rsi': signals[2].get('rsi', 50),
            
            'agent_4_3wave': signals[3]['signal'],
            'agent_4_conf': signals[3]['confidence'],
            'agent_4_reasons': ' | '.join(signals[3].get('reasons', [])),
            
            # Votes
            'call_votes': call_count,
            'put_votes': put_count,
            'hold_votes': hold_count,
            
            # Confluence
            'confluence_level': confluence_level,
            'agreement_count': agreement_count,
            'approved': approved,
            'rejection': rejection,
            
            # Final
            'final': consensus,
            'confidence': round(avg_conf, 2) if approved else 0,
            'entry': round(entry, 2),
            'stop': round(stop, 2),
            'target1': round(t1, 2),
            'target2': round(t2, 2),
            'target3': round(t3, 2),
        }
        
        self.all_signals.append(result)
        
        if approved and consensus != 'HOLD':
            self.super_signals.append(result)
            if confluence_level == 'ULTRA':
                self.ultra_signals.append(result)
        
        return result
    
    def run(self, data):
        """Run all 4 agents on dataset."""
        logger.info("=" * 70)
        logger.info("  Q5D 4-AGENT UNIFIED ORCHESTRATOR")
        logger.info("=" * 70)
        logger.info(f"  Agents: {', '.join([a.name for a in self.agents])}")
        logger.info(f"  Minimum Agreement: {self.min_agreement}/4")
        logger.info(f"  Processing {len(data)} bars...")
        logger.info("")
        
        for i in range(len(data)):
            self.process_bar(data, i)
            if (i + 1) % 100 == 0:
                logger.info(f"  Processed {i + 1}/{len(data)} bars...")
        
        self._save_reports()
        self._print_summary()
        
        return self.stats
    
    def _save_reports(self):
        """Save all reports."""
        
        # 1. Super Confluence Signals (3+ agree)
        if self.super_signals:
            df = pd.DataFrame(self.super_signals)
            path = os.path.join(REPORTS_DIR, 'super_confluence_signals.csv')
            df.to_csv(path, index=False)
            logger.info(f"  Saved: {path} ({len(df)} signals)")
        
        # 2. Playbook Comparison (all 4 agents)
        if self.all_signals:
            df = pd.DataFrame(self.all_signals)
            path = os.path.join(REPORTS_DIR, 'playbook_comparison.csv')
            df.to_csv(path, index=False)
            logger.info(f"  Saved: {path}")
        
        # 3. Full Tracking
        if self.all_signals:
            df = pd.DataFrame(self.all_signals)
            path = os.path.join(REPORTS_DIR, 'super_confluence_tracking.csv')
            df.to_csv(path, index=False)
            logger.info(f"  Saved: {path}")
        
        # 4. Agreement Analysis
        calls = len([s for s in self.super_signals if s['final'] == 'CALL'])
        puts = len([s for s in self.super_signals if s['final'] == 'PUT'])
        
        analysis = {
            'generated_at': datetime.now().isoformat(),
            'agents': [a.name for a in self.agents],
            'min_agreement': self.min_agreement,
            'statistics': self.stats,
            'confluence_summary': {
                'ultra_4_4': self.stats['ultra_confluence'],
                'super_3_4': self.stats['super_confluence'],
                'partial_2_4': self.stats['partial_confluence'],
                'none': self.stats['no_confluence'],
            },
            'approved_signals': {
                'total': len(self.super_signals),
                'calls': calls,
                'puts': puts,
                'ultra_only': len(self.ultra_signals),
            },
            'agent_activity': self.stats['agent_signals'],
        }
        
        path = os.path.join(REPORTS_DIR, 'agreement_analysis.json')
        with open(path, 'w') as f:
            json.dump(analysis, f, indent=2)
        logger.info(f"  Saved: {path}")
    
    def _print_summary(self):
        """Print summary."""
        calls = len([s for s in self.super_signals if s['final'] == 'CALL'])
        puts = len([s for s in self.super_signals if s['final'] == 'PUT'])
        
        print("\n")
        print("=" * 70)
        print("  Q5D 4-AGENT ORCHESTRATOR - SUMMARY")
        print("=" * 70)
        print("")
        print("  AGENTS")
        for agent in self.agents:
            count = self.stats['agent_signals'][agent.name]
            print(f"    {agent.icon} {agent.name}: {count} signals")
        print("")
        print("  CONFLUENCE LEVELS")
        print(f"    üî• ULTRA (4/4):    {self.stats['ultra_confluence']}")
        print(f"    ‚≠ê SUPER (3/4):    {self.stats['super_confluence']}")
        print(f"    üìä PARTIAL (2/4):  {self.stats['partial_confluence']}")
        print(f"    ‚ùå NONE (<2):      {self.stats['no_confluence']}")
        print("")
        print("  APPROVED TRADES (3+ Agreement + R:R ‚â• 2:1)")
        print(f"    Total Approved:    {len(self.super_signals)}")
        print(f"    CALL Signals:      {calls}")
        print(f"    PUT Signals:       {puts}")
        print(f"    Rejected (R:R):    {self.stats['rejected_rr']}")
        print("")
        
        if self.super_signals:
            avg_conf = np.mean([s['confidence'] for s in self.super_signals])
            print(f"    Avg Confidence:    {avg_conf:.0%}")
        
        print("")
        print("  OUTPUT FILES")
        print("    reports/super_confluence_signals.csv")
        print("    reports/playbook_comparison.csv")
        print("    reports/agreement_analysis.json")
        print("=" * 70)
        
        if self.super_signals:
            print("\n  RECENT APPROVED SIGNALS (Last 5)")
            print("  " + "-" * 60)
            for s in self.super_signals[-5:]:
                print(f"  {s['date']}: {s['final']} @ ${s['close']:.2f}")
                print(f"    Level: {s['confluence_level']} ({s['agreement_count']}/4 agree)")
                print(f"    Votes: CALL={s['call_votes']}, PUT={s['put_votes']}, HOLD={s['hold_votes']}")
                print(f"    Stop: ${s['stop']:.2f} | T1: ${s['target1']:.2f} | T2: ${s['target2']:.2f}")
                print("")


def load_data():
    """Load SPY data."""
    paths = [
        os.path.join(DATA_DIR, 'SPY_confluence.csv'),
        os.path.join(DATA_DIR, 'SPY.csv'),
        'SPY.csv',
    ]
    
    for path in paths:
        if os.path.exists(path):
            df = pd.read_csv(path)
            logger.info(f"Loaded: {path} ({len(df)} rows)")
            return df
    
    raise FileNotFoundError("No SPY data found")


def main():
    print("\n")
    print("=" * 70)
    print("  Q5D 4-AGENT UNIFIED ORCHESTRATOR")
    print("  Super Confluence = 3+ Agents Agree")
    print("=" * 70)
    print(f"  Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    try:
        data = load_data()
    except FileNotFoundError as e:
        logger.error(str(e))
        return
    
    orchestrator = UnifiedOrchestrator(min_agreement=3)
    orchestrator.run(data)


if __name__ == "__main__":
    main()