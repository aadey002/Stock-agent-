<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Agent 4 - Professional Trading Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #1e40af; --secondary: #7c3aed; --accent: #ec4899;
            --success: #16a34a; --danger: #dc2626; --warning: #d97706; --info: #0891b2;
            --bg-white: #ffffff; --bg-light: #f8fafc; --bg-gray: #f3f4f6;
            --border: #e5e7eb; --text-dark: #1f2937; --text-gray: #6b7280; --text-light: #9ca3af;
        }
        body { font-family: 'Segoe UI', 'Roboto', sans-serif; background: linear-gradient(135deg, var(--bg-light) 0%, var(--bg-white) 50%, #f0f9ff 100%); min-height: 100vh; color: var(--text-dark); line-height: 1.6; }
        .header { background: var(--bg-white); border-bottom: 2px solid var(--border); padding: 20px 0; position: sticky; top: 0; z-index: 100; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .header-content { max-width: 1600px; margin: 0 auto; padding: 0 30px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 20px; }
        .logo { display: flex; align-items: center; gap: 15px; }
        .logo-icon { width: 50px; height: 50px; background: linear-gradient(135deg, var(--primary), var(--secondary)); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 28px; color: white; }
        .logo h1 { font-size: 24px; font-weight: 700; }
        .logo p { font-size: 12px; color: var(--text-gray); }
        .header-controls { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .status-indicator { display: flex; align-items: center; gap: 8px; padding: 8px 15px; background: rgba(22,163,74,0.1); border: 1px solid var(--success); border-radius: 20px; font-size: 12px; font-weight: 600; color: var(--success); }
        .status-indicator.offline { background: rgba(220,38,38,0.1); border-color: var(--danger); color: var(--danger); }
        .status-dot { width: 8px; height: 8px; background: currentColor; border-radius: 50%; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .symbol-selector { display: flex; gap: 10px; align-items: center; }
        .symbol-selector label { font-size: 13px; font-weight: 600; }
        .symbol-selector select { padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; }
        .refresh-btn { padding: 10px 18px; background: var(--primary); color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; }
        .refresh-btn:hover { background: #1e3a8a; }
        .container { max-width: 1600px; margin: 0 auto; padding: 30px; }
        .alert-banner { padding: 15px 20px; background: rgba(22,163,74,0.1); border: 1px solid var(--success); border-radius: 8px; margin-bottom: 25px; display: flex; align-items: center; gap: 10px; }
        .alert-banner.error { background: rgba(220,38,38,0.1); border-color: var(--danger); }
        .alert-banner strong { color: var(--success); }
        .alert-banner.error strong { color: var(--danger); }
        .tabs { display: flex; gap: 10px; margin-bottom: 30px; border-bottom: 2px solid var(--border); padding-bottom: 15px; overflow-x: auto; }
        .tab-btn { padding: 12px 20px; background: transparent; border: none; border-bottom: 3px solid transparent; color: var(--text-gray); font-size: 14px; font-weight: 600; cursor: pointer; white-space: nowrap; }
        .tab-btn:hover { color: var(--primary); }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .section-title { font-size: 18px; font-weight: 700; margin-bottom: 20px; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric-card { background: var(--bg-white); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .metric-label { font-size: 11px; font-weight: 600; color: var(--text-gray); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px; }
        .metric-value { font-size: 28px; font-weight: 700; }
        .metric-value.positive { color: var(--success); }
        .metric-value.negative { color: var(--danger); }
        .metric-sub { font-size: 12px; color: var(--text-light); margin-top: 5px; }
        .card { background: var(--bg-white); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        table { width: 100%; border-collapse: collapse; }
        th { text-align: left; padding: 12px 15px; font-size: 11px; font-weight: 600; color: var(--text-gray); text-transform: uppercase; background: var(--bg-gray); border-bottom: 1px solid var(--border); }
        td { padding: 12px 15px; font-size: 13px; border-bottom: 1px solid var(--border); }
        tr:last-child td { border-bottom: none; }
        .badge { display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 11px; font-weight: 600; text-transform: uppercase; }
        .badge-success { background: rgba(22,163,74,0.1); color: var(--success); }
        .badge-danger { background: rgba(220,38,38,0.1); color: var(--danger); }
        .badge-warning { background: rgba(217,119,6,0.1); color: var(--warning); }
        .badge-info { background: rgba(8,145,178,0.1); color: var(--info); }
        .empty-state { text-align: center; padding: 40px; color: var(--text-light); }
        .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px; }
        .chart-container { background: var(--bg-white); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .chart-container h3 { font-size: 14px; font-weight: 600; margin-bottom: 15px; }

        /* Options Calculator & AI Analyzer Styles */
        .options-calc-container { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        @media (max-width: 900px) { .options-calc-container { grid-template-columns: 1fr; } }
        .calc-input-panel { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .calc-input-panel h3 { font-size: 16px; margin-bottom: 15px; color: var(--primary); }
        .calc-form-group { margin-bottom: 15px; }
        .calc-form-group label { display: block; font-size: 12px; font-weight: 600; color: var(--muted); margin-bottom: 5px; }
        .calc-form-group input, .calc-form-group select { width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; }
        .calc-form-group input:focus, .calc-form-group select:focus { border-color: var(--primary); outline: none; }
        .calc-type-toggle { display: flex; gap: 10px; margin-bottom: 15px; }
        .calc-type-btn { flex: 1; padding: 12px; border: 2px solid var(--border); background: white; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.3s; }
        .calc-type-btn.active.call { border-color: var(--success); background: rgba(16,185,129,0.1); color: var(--success); }
        .calc-type-btn.active.put { border-color: var(--danger); background: rgba(239,68,68,0.1); color: var(--danger); }
        .calc-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 700; cursor: pointer; margin-bottom: 10px; }
        .calc-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .calc-btn.secondary { background: var(--secondary); }
        .calc-btn.ai { background: linear-gradient(135deg, #667eea, #764ba2); }
        .calc-results-panel { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .calc-results-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
        @media (max-width: 600px) { .calc-results-grid { grid-template-columns: repeat(2, 1fr); } }
        .calc-result-item { text-align: center; padding: 15px; background: var(--bg); border-radius: 8px; }
        .calc-result-item .label { font-size: 11px; color: var(--muted); margin-bottom: 5px; }
        .calc-result-item .value { font-size: 20px; font-weight: 700; }
        .calc-result-item .value.profit { color: var(--success); }
        .calc-result-item .value.loss { color: var(--danger); }
        .calc-chart-container { height: 300px; background: var(--bg); border-radius: 8px; padding: 15px; }
        .calc-pnl-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 12px; }
        .calc-pnl-table th, .calc-pnl-table td { padding: 8px 12px; text-align: center; border-bottom: 1px solid var(--border); }
        .calc-pnl-table th { background: var(--bg); font-weight: 600; color: var(--muted); }
        .calc-pnl-table .profit { color: var(--success); font-weight: 600; }
        .calc-pnl-table .loss { color: var(--danger); font-weight: 600; }
        
        /* AI Options Analyzer */
        .ai-options-panel { background: linear-gradient(135deg, rgba(102,126,234,0.05), rgba(118,75,162,0.05)); border: 1px solid rgba(102,126,234,0.3); border-radius: 12px; padding: 20px; margin-top: 20px; }
        .ai-options-panel h3 { color: #764ba2; margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .ai-recommendation { background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px; border-left: 4px solid var(--success); }
        .ai-recommendation.high { border-left-color: var(--success); }
        .ai-recommendation.medium { border-left-color: var(--warning); }
        .ai-recommendation.low { border-left-color: var(--danger); }
        .ai-recommendation-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .ai-recommendation-title { font-weight: 700; font-size: 14px; }
        .ai-recommendation-score { padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 700; }
        .ai-recommendation-score.high { background: rgba(16,185,129,0.2); color: var(--success); }
        .ai-recommendation-score.medium { background: rgba(245,158,11,0.2); color: var(--warning); }
        .ai-recommendation-details { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; font-size: 11px; }
        .ai-recommendation-details .item { text-align: center; }
        .ai-recommendation-details .item .label { color: var(--muted); }
        .ai-recommendation-details .item .value { font-weight: 700; margin-top: 2px; }
        .ai-analysis-text { background: var(--bg); padding: 12px; border-radius: 8px; font-size: 12px; line-height: 1.6; margin-top: 10px; }

        /* Enhanced Multi-Chart Analysis Styles */
        .chart-analysis-panel { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 15px; margin-top: 15px; }
        .chart-analysis-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border); }
        .chart-analysis-title { font-weight: 700; font-size: 14px; }
        .timeframe-badge { padding: 4px 12px; border-radius: 15px; font-size: 11px; font-weight: 700; background: var(--primary); color: white; }
        
        .analysis-sections { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        @media (max-width: 1200px) { .analysis-sections { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .analysis-sections { grid-template-columns: 1fr; } }
        
        .analysis-section { background: var(--bg); border-radius: 8px; padding: 12px; }
        .analysis-section-title { font-size: 12px; font-weight: 700; color: var(--primary); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
        .analysis-section-content { font-size: 11px; }
        .level-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px dashed var(--border); }
        .level-row:last-child { border-bottom: none; }
        .level-label { color: var(--muted); }
        .level-value { font-weight: 600; }
        .level-value.resistance { color: var(--danger); }
        .level-value.support { color: var(--success); }
        .level-value.fib { color: var(--primary); }
        .level-value.divine { color: #9333ea; }
        
        .pattern-tag { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; margin: 2px; }
        .pattern-tag.bullish { background: rgba(16,185,129,0.2); color: var(--success); }
        .pattern-tag.bearish { background: rgba(239,68,68,0.2); color: var(--danger); }
        .pattern-tag.neutral { background: rgba(107,114,128,0.2); color: #6b7280; }
        
        .xo-chart { font-family: monospace; font-size: 10px; line-height: 1.2; background: #1a1a2e; color: #fff; padding: 10px; border-radius: 6px; overflow-x: auto; }
        .xo-x { color: #10b981; }
        .xo-o { color: #ef4444; }
        
        /* Trade Scenario Tabs */
        .scenario-tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .scenario-tab { padding: 12px 24px; border: 2px solid var(--border); background: white; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.3s; }
        .scenario-tab.active { border-color: var(--primary); background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1)); color: var(--primary); }
        .scenario-tab:hover { border-color: var(--primary); }
        
        .setup-patterns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .setup-pattern { padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; }
        .setup-pattern.active { background: var(--success); color: white; }
        .setup-pattern.potential { background: rgba(245,158,11,0.2); color: var(--warning); border: 1px dashed var(--warning); }
        .setup-pattern.inactive { background: var(--bg); color: var(--muted); }
        
        /* Divine Proportions */
        .divine-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .divine-item { text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(147,51,234,0.1), rgba(168,85,247,0.1)); border-radius: 6px; }
        .divine-label { font-size: 9px; color: var(--muted); }
        .divine-value { font-size: 12px; font-weight: 700; color: #9333ea; }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">üìä</div>
                <div><h1>Stock Agent 4</h1><p>Professional Trading Dashboard</p></div>
            </div>
            <div class="header-controls">
                <div class="status-indicator" id="statusIndicator">
                    <span class="status-dot"></span>
                    <span id="serverStatus">OFFLINE</span>
                </div>
                <div class="symbol-selector">
                    <label>Symbol:</label>
                    <select id="symbol-select" onchange="loadAllData()">
                        <option value="SPY">SPY - S&P 500</option>
                        <option value="QQQ">QQQ - Nasdaq</option>
                        <option value="IWM">IWM - Russell 2000</option>
                        <option value="DIA">DIA - Dow Jones</option>
                    </select>
                </div>
                <button class="refresh-btn" onclick="loadAllData()">Refresh Data</button>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="alert-banner" id="alertBanner">
            <span>‚úì</span>
            <span><strong>Backend Connected:</strong> <span id="alertMessage">Loading data...</span></span>
        </div>

        <div class="tabs">
            <button class="tab-btn active" data-tab="overview">Overview</button>
            <button class="tab-btn" data-tab="realtime">Real-Time Data</button>
            <button class="tab-btn" data-tab="signals">Signals</button>
            <button class="tab-btn" data-tab="agents">Agents</button>
            <button class="tab-btn" data-tab="analytics">Analytics</button>
        </div>

        <div id="overview" class="tab-content active">
            <h2 class="section-title">Dashboard Overview</h2>
            <div class="metrics-grid">
                <div class="metric-card"><div class="metric-label">Current Price</div><div class="metric-value" id="currentPrice">--</div><div class="metric-sub" id="priceDate">Loading...</div></div>
                <div class="metric-card"><div class="metric-label">24H Change</div><div class="metric-value" id="dailyChange">--</div><div class="metric-sub" id="changePct">--</div></div>
                <div class="metric-card"><div class="metric-label">Volume</div><div class="metric-value" id="volume">--</div><div class="metric-sub">Daily volume</div></div>
                <div class="metric-card"><div class="metric-label">Signal Status</div><div class="metric-value" id="signalStatus">--</div><div class="metric-sub">From agents</div></div>
            </div>
            <h2 class="section-title">Latest Trading Signal</h2>
            <div class="card"><table><thead><tr><th>Symbol</th><th>Price</th><th>Base Confluence</th><th>Gann-Elliott</th><th>RL/DQN</th><th>Agreement</th><th>Strength</th><th>Confidence</th></tr></thead><tbody id="signalTable"><tr><td colspan="8" class="empty-state">Loading signal data...</td></tr></tbody></table></div>
        </div>

        <div id="realtime" class="tab-content">
            <h2 class="section-title">Real-Time Market Data</h2>
            <div class="metrics-grid">
                <div class="metric-card"><div class="metric-label">Open</div><div class="metric-value" id="openPrice">--</div></div>
                <div class="metric-card"><div class="metric-label">High / Low</div><div class="metric-value" id="highLow" style="font-size:20px">--</div></div>
                <div class="metric-card"><div class="metric-label">ATR (14)</div><div class="metric-value" id="atr">--</div></div>
                <div class="metric-card"><div class="metric-label">Bars</div><div class="metric-value" id="barCount">--</div></div>
            </div>
            <div class="card"><h3 style="margin-bottom:15px">Price Chart (60 Days)</h3><canvas id="priceChart" height="100"></canvas></div>
        </div>

        <div id="signals" class="tab-content">
            <h2 class="section-title">Trade History</h2>
            <div class="card"><table><thead><tr><th>Symbol</th><th>Signal</th><th>Entry Date</th><th>Exit Date</th><th>Entry $</th><th>Exit $</th><th>P&L</th><th>Status</th></tr></thead><tbody id="tradeTable"><tr><td colspan="8" class="empty-state">Loading trades...</td></tr></tbody></table></div>
        </div>

        <div id="agents" class="tab-content">
            <h2 class="section-title">Agent Status</h2>
            <div class="metrics-grid">
                <div class="metric-card"><div class="metric-label">Base Confluence</div><div class="metric-value" style="color:var(--success)">ACTIVE</div><div class="metric-sub">SMA + ATR</div></div>
                <div class="metric-card"><div class="metric-label">Gann-Elliott</div><div class="metric-value" style="color:var(--success)">ACTIVE</div><div class="metric-sub">Geo + Phi Levels</div></div>
                <div class="metric-card"><div class="metric-label">DQN/RL</div><div class="metric-value" style="color:var(--success)">ACTIVE</div><div class="metric-sub">ML Agent</div></div>
                <div class="metric-card"><div class="metric-label">Super Confluence</div><div class="metric-value" style="color:var(--primary)">2/3 VOTE</div><div class="metric-sub">Consensus</div></div>
            </div>
        </div>

        <div id="analytics" class="tab-content">
            <h2 class="section-title">Performance Analytics</h2>
            <div class="metrics-grid">
                <div class="metric-card"><div class="metric-label">Total Trades</div><div class="metric-value" id="totalTrades">--</div></div>
                <div class="metric-card"><div class="metric-label">Win Rate</div><div class="metric-value" id="winRate">--</div></div>
                <div class="metric-card"><div class="metric-label">Total P&L</div><div class="metric-value" id="totalPnl">--</div></div>
                <div class="metric-card"><div class="metric-label">Last Updated</div><div class="metric-value" id="lastUpdate" style="font-size:16px">--</div></div>
            </div>
            <div class="chart-grid">
                <div class="chart-container"><h3>Win Rate by Agent</h3><canvas id="winRateChart"></canvas></div>
                <div class="chart-container"><h3>Average Return</h3><canvas id="avgReturnChart"></canvas></div>
            </div>
        </div>
    </div>

<script>
let priceChart = null, spyData = [], trades = [];

window.addEventListener('DOMContentLoaded', () => { initTabs(); loadAllData(); });

function parseCSV(t) {
    const l = t.trim().split('\n'); if (l.length < 2) return [];
    const h = l[0].split(',').map(x => x.trim());
    return l.slice(1).map(r => { const v = r.split(','), o = {}; h.forEach((k,i) => o[k] = v[i]?.trim() || ''); return o; });
}

function setStatus(on, msg) {
    const el = document.getElementById('statusIndicator'), st = document.getElementById('serverStatus');
    const ban = document.getElementById('alertBanner'), am = document.getElementById('alertMessage');
    el.className = 'status-indicator' + (on ? '' : ' offline');
    st.textContent = on ? 'ONLINE' : 'OFFLINE';
    ban.className = 'alert-banner' + (on ? '' : ' error');
    ban.querySelector('strong').textContent = on ? 'Backend Connected:' : 'Connection Error:';
    am.textContent = msg;
}

async function loadAllData() {
    try {
        let connected = false;
        // Load API status
        try {
            const r = await fetch('data/api_status.json?t=' + Date.now());
            if (r.ok) {
                const d = await r.json();
                connected = d.tiingo_connected;
                if (d.spy_price) document.getElementById('currentPrice').textContent = '$' + d.spy_price.toFixed(2);
                if (d.spy_change !== null) {
                    const c = d.spy_change;
                    document.getElementById('dailyChange').textContent = (c>=0?'+':'') + c.toFixed(2);
                    document.getElementById('dailyChange').className = 'metric-value ' + (c>=0?'positive':'negative');
                }
                document.getElementById('barCount').textContent = d.bar_count || '--';
                setStatus(connected, connected ? 'Tiingo data loaded. Last: ' + (d.last_bar_date||'') : d.message || 'Waiting for refresh');
            }
        } catch(e) {}

        // Load SPY CSV
        let r = await fetch('data/SPY.csv?t='+Date.now()).catch(()=>null);
        if (!r?.ok) r = await fetch('data/SPY_confluence.csv?t='+Date.now()).catch(()=>null);
        if (r?.ok) {
            spyData = parseCSV(await r.text());
            if (spyData.length) {
                const lat = spyData[spyData.length-1], prev = spyData[spyData.length-2] || lat;
                const price = parseFloat(lat.Close)||0, pp = parseFloat(prev.Close)||price;
                const chg = price - pp, pct = pp ? (chg/pp*100) : 0;
                document.getElementById('currentPrice').textContent = '$' + price.toFixed(2);
                document.getElementById('priceDate').textContent = lat.Date || '';
                document.getElementById('dailyChange').textContent = (chg>=0?'+':'') + chg.toFixed(2);
                document.getElementById('dailyChange').className = 'metric-value ' + (chg>=0?'positive':'negative');
                document.getElementById('changePct').textContent = (pct>=0?'+':'') + pct.toFixed(2) + '%';
                document.getElementById('volume').textContent = ((parseFloat(lat.Volume)||0)/1e6).toFixed(2) + 'M';
                document.getElementById('openPrice').textContent = '$' + (parseFloat(lat.Open)||0).toFixed(2);
                document.getElementById('highLow').textContent = '$'+(parseFloat(lat.Low)||0).toFixed(2)+' - $'+(parseFloat(lat.High)||0).toFixed(2);
                document.getElementById('atr').textContent = (parseFloat(lat.ATR)||0).toFixed(2);
                document.getElementById('barCount').textContent = spyData.length;
                const bias = (lat.Bias||'').toUpperCase();
                document.getElementById('signalStatus').textContent = bias || 'NEUTRAL';
                updateSignalTable(lat);
                updateChart();
                if (!connected) setStatus(true, 'Data loaded from CSV. ' + spyData.length + ' bars.');
            }
        }

        // Load trades
        r = await fetch('data/portfolio_confluence.csv?t='+Date.now()).catch(()=>null);
        if (!r?.ok) r = await fetch('reports/portfolio_confluence.csv?t='+Date.now()).catch(()=>null);
        if (r?.ok) {
            trades = parseCSV(await r.text());
            const tb = document.getElementById('tradeTable');
            if (!trades.length) { tb.innerHTML = '<tr><td colspan="8" class="empty-state">No trades</td></tr>'; }
            else {
                tb.innerHTML = [...trades].reverse().map(t => {
                    const pnl = parseFloat(t.PNL)||0;
                    return `<tr><td>${t.Symbol||'--'}</td><td><span class="badge badge-${t.Signal?.toUpperCase()==='CALL'?'success':'danger'}">${t.Signal||'--'}</span></td><td>${t.EntryDate||'--'}</td><td>${t.ExitDate||'--'}</td><td>$${(parseFloat(t.EntryPrice)||0).toFixed(2)}</td><td>$${(parseFloat(t.ExitPrice)||0).toFixed(2)}</td><td><span class="badge badge-${pnl>=0?'success':'danger'}">${pnl>=0?'+':''}$${pnl.toFixed(2)}</span></td><td>${t.Status||'--'}</td></tr>`;
                }).join('');
            }
            document.getElementById('totalTrades').textContent = trades.length;
            const closed = trades.filter(t=>t.PNL), wins = closed.filter(t=>parseFloat(t.PNL)>0);
            document.getElementById('winRate').textContent = closed.length ? (wins.length/closed.length*100).toFixed(1)+'%' : '--';
            const total = closed.reduce((s,t)=>s+(parseFloat(t.PNL)||0),0);
            document.getElementById('totalPnl').textContent = (total>=0?'+':'')+'$'+total.toFixed(2);
            document.getElementById('totalPnl').className = 'metric-value '+(total>=0?'positive':'negative');
        }
        document.getElementById('lastUpdate').textContent = new Date().toLocaleString();
        initCharts();
    } catch(e) { setStatus(false, 'Error: '+e.message); }
}

function updateSignalTable(d) {
    const bias = (d.Bias||'').toUpperCase(), sig = bias==='CALL'?'CALL':(bias==='PUT'?'PUT':'HOLD');
    const cls = sig==='CALL'?'success':(sig==='PUT'?'danger':'warning');
    document.getElementById('signalTable').innerHTML = `<tr><td>SPY</td><td>$${(parseFloat(d.Close)||0).toFixed(2)}</td><td><span class="badge badge-${cls}">${sig}</span></td><td><span class="badge badge-${cls}">${sig}</span></td><td><span class="badge badge-info">ML</span></td><td>2/3</td><td><strong>${sig==='HOLD'?'NEUTRAL':'STRONG'}</strong></td><td>75%</td></tr>`;
}

function updateChart() {
    if (!spyData.length) return;
    const data = spyData.slice(-60);
    const ctx = document.getElementById('priceChart');
    if (priceChart) priceChart.destroy();
    priceChart = new Chart(ctx, {
        type: 'line',
        data: { labels: data.map(d=>d.Date?.slice(5)||''), datasets: [{ label: 'Close', data: data.map(d=>parseFloat(d.Close)||0), borderColor: '#1e40af', backgroundColor: 'rgba(30,64,175,0.05)', fill: true, tension: 0.4, pointRadius: 2 }] },
        options: { responsive: true, scales: { y: { ticks: { callback: v=>'$'+v } } } }
    });
}

function initCharts() {
    const w = document.getElementById('winRateChart');
    if (w && !w.dataset.init) { new Chart(w, { type:'bar', data:{ labels:['Base','Gann','DQN','SUPER','ULTRA'], datasets:[{label:'Win %',data:[65,72,71,78,89],backgroundColor:['#1e40af','#7c3aed','#ec4899','#16a34a','#059669']}]}, options:{responsive:true}}); w.dataset.init='1'; }
    const a = document.getElementById('avgReturnChart');
    if (a && !a.dataset.init) { new Chart(a, { type:'bar', data:{ labels:['Base','Gann','DQN','SUPER','ULTRA'], datasets:[{label:'Avg R',data:[1.8,2.1,1.9,2.4,3.2],backgroundColor:['#1e40af','#7c3aed','#ec4899','#16a34a','#059669']}]}, options:{responsive:true}}); a.dataset.init='1'; }
}

function initTabs() {
    document.querySelectorAll('.tab-btn').forEach(b => {
        b.onclick = () => {
            document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(x=>x.classList.remove('active'));
            document.getElementById(b.dataset.tab).classList.add('active');
            b.classList.add('active');
        };
    });
}

setInterval(loadAllData, 60000);

// ============================================
// AI-POWERED OPTIONS PROFIT CALCULATOR
// ============================================

let optionType = 'call';
let optionsPnLChart = null;

function setOptionType(type) {
    optionType = type;
    document.querySelectorAll('.calc-type-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(.calc-type-btn.).classList.add('active');
}

function updateCalcPrice() {
    if (currentData && currentData.length > 0) {
        const lastBar = currentData[currentData.length - 1];
        const price = parseFloat(lastBar.Close);
        if (price > 0) {
            document.getElementById('calcStockPrice').value = price.toFixed(2);
            document.getElementById('calcStrikePrice').value = Math.round(price);
        }
    }
}

function useAgentSignal() {
    const signalEl = document.getElementById('signalStatus');
    const priceEl = document.getElementById('currentPrice');
    
    if (signalEl && priceEl) {
        const signal = signalEl.textContent.toUpperCase();
        const price = parseFloat(priceEl.textContent.replace('$', ''));
        
        if (signal.includes('CALL')) setOptionType('call');
        else if (signal.includes('PUT')) setOptionType('put');
        
        if (price > 0) {
            document.getElementById('calcStockPrice').value = price.toFixed(2);
            document.getElementById('calcStrikePrice').value = Math.round(price);
            
            const atrEl = document.getElementById('atrDisplay');
            if (atrEl) {
                const atr = parseFloat(atrEl.textContent);
                if (atr > 0) document.getElementById('calcPremium').value = (atr * 0.5).toFixed(2);
            }
        }
    }
    calculateOptionsProfit();
}

function calculateOptionsProfit() {
    const stockPrice = parseFloat(document.getElementById('calcStockPrice').value);
    const strikePrice = parseFloat(document.getElementById('calcStrikePrice').value);
    const premium = parseFloat(document.getElementById('calcPremium').value);
    const contracts = parseInt(document.getElementById('calcContracts').value);
    
    if (isNaN(stockPrice) || isNaN(strikePrice) || isNaN(premium)) {
        alert('Please fill in all fields');
        return;
    }
    
    const costBasis = premium * 100 * contracts;
    let breakEven, maxProfit, maxLoss;
    
    if (optionType === 'call') {
        breakEven = strikePrice + premium;
        maxLoss = costBasis;
        maxProfit = 'Unlimited';
    } else {
        breakEven = strikePrice - premium;
        maxLoss = costBasis;
        maxProfit = (strikePrice - premium) * 100 * contracts;
    }
    
    document.getElementById('calcMaxProfit').textContent = typeof maxProfit === 'number' ? '$' + maxProfit.toFixed(0) : maxProfit;
    document.getElementById('calcMaxLoss').textContent = '-$' + maxLoss.toFixed(0);
    document.getElementById('calcBreakEven').textContent = '$' + breakEven.toFixed(2);
    
    // Risk/Reward at expected move
    const expectedMove = parseFloat(document.getElementById('calcExpectedMove').value) / 100;
    const targetPrice = optionType === 'call' ? stockPrice * (1 + expectedMove) : stockPrice * (1 - expectedMove);
    let targetProfit;
    
    if (optionType === 'call') {
        targetProfit = Math.max(0, (targetPrice - strikePrice - premium)) * 100 * contracts;
    } else {
        targetProfit = Math.max(0, (strikePrice - targetPrice - premium)) * 100 * contracts;
    }
    
    const riskReward = maxLoss > 0 ? (targetProfit / maxLoss).toFixed(2) : 0;
    document.getElementById('calcRiskReward').textContent = riskReward + ':1';
    
    generatePnLTable(stockPrice, strikePrice, premium, contracts);
    generatePnLChart(stockPrice, strikePrice, premium, contracts);
}

function generatePnLTable(stockPrice, strikePrice, premium, contracts) {
    const tbody = document.getElementById('pnlTableBody');
    tbody.innerHTML = '';
    
    const range = stockPrice * 0.15;
    const prices = [];
    for (let p = stockPrice - range; p <= stockPrice + range; p += range/5) {
        prices.push(Math.round(p));
    }
    
    prices.forEach(price => {
        let optionValue = optionType === 'call' ? Math.max(0, price - strikePrice) : Math.max(0, strikePrice - price);
        let pnlPerContract = (optionValue - premium) * 100;
        let totalPnl = pnlPerContract * contracts;
        let percentReturn = premium > 0 ? ((optionValue - premium) / premium * 100) : 0;
        
        const row = document.createElement('tr');
        row.innerHTML = 
            <td>confluence_agent.yml{price}</td>
            <td>confluence_agent.yml{optionValue.toFixed(2)}</td>
            <td class="">confluence_agent.yml{pnlPerContract.toFixed(0)}</td>
            <td class="">confluence_agent.yml{totalPnl.toFixed(0)}</td>
            <td class="">%</td>
        ;
        tbody.appendChild(row);
    });
}

function generatePnLChart(stockPrice, strikePrice, premium, contracts) {
    const ctx = document.getElementById('optionsPnLChart').getContext('2d');
    if (optionsPnLChart) optionsPnLChart.destroy();
    
    const range = stockPrice * 0.20;
    const labels = [], data = [];
    
    for (let p = stockPrice - range; p <= stockPrice + range; p += range/20) {
        labels.push(p.toFixed(0));
        let pnl = optionType === 'call' 
            ? (Math.max(0, p - strikePrice) - premium) * 100 * contracts
            : (Math.max(0, strikePrice - p) - premium) * 100 * contracts;
        data.push(pnl);
    }
    
    optionsPnLChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'P&L ($)',
                data: data,
                borderColor: optionType === 'call' ? '#10b981' : '#ef4444',
                backgroundColor: optionType === 'call' ? 'rgba(16,185,129,0.1)' : 'rgba(239,68,68,0.1)',
                fill: true, tension: 0.1, pointRadius: 2
            }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                annotation: {
                    annotations: {
                        zeroline: { type: 'line', yMin: 0, yMax: 0, borderColor: '#64748b', borderWidth: 2, borderDash: [5,5] }
                    }
                }
            },
            scales: {
                x: { title: { display: true, text: 'Stock Price at Expiry' }, grid: { color: 'rgba(0,0,0,0.05)' } },
                y: { title: { display: true, text: 'Profit/Loss ($)' }, grid: { color: 'rgba(0,0,0,0.05)' } }
            }
        }
    });
}

// ============================================
// AI OPTIONS ANALYZER - FIND BEST STRIKES
// ============================================

function aiAnalyzeBestOptions() {
    const stockPrice = parseFloat(document.getElementById('calcStockPrice').value);
    const expectedMove = parseFloat(document.getElementById('calcExpectedMove').value) / 100;
    const dte = parseInt(document.getElementById('calcDTE').value);
    
    if (isNaN(stockPrice)) {
        alert('Please enter a valid stock price');
        return;
    }
    
    document.getElementById('aiOptionsPanel').style.display = 'block';
    
    // Simulate ATR-based premium estimation
    const atrEstimate = stockPrice * 0.015; // ~1.5% daily move
    const recommendations = [];
    
    // Analyze multiple strike prices
    const strikes = [
        { offset: -5, label: 'Deep ITM' },
        { offset: -2, label: 'ITM' },
        { offset: 0, label: 'ATM' },
        { offset: 2, label: 'OTM' },
        { offset: 5, label: 'Far OTM' }
    ];
    
    strikes.forEach(strike => {
        const strikePrice = Math.round(stockPrice + strike.offset);
        const intrinsic = optionType === 'call' 
            ? Math.max(0, stockPrice - strikePrice)
            : Math.max(0, strikePrice - stockPrice);
        
        // Estimate premium based on moneyness and DTE
        const timeValue = atrEstimate * Math.sqrt(dte / 365) * 10;
        const premium = intrinsic + timeValue + Math.max(0, 2 - Math.abs(strike.offset)) * 0.5;
        
        // Calculate expected P&L
        const targetPrice = optionType === 'call' 
            ? stockPrice * (1 + expectedMove)
            : stockPrice * (1 - expectedMove);
        
        const optionValueAtTarget = optionType === 'call'
            ? Math.max(0, targetPrice - strikePrice)
            : Math.max(0, strikePrice - targetPrice);
        
        const expectedPnL = (optionValueAtTarget - premium) * 100;
        const maxLoss = premium * 100;
        const riskReward = maxLoss > 0 ? expectedPnL / maxLoss : 0;
        const percentReturn = premium > 0 ? (expectedPnL / (premium * 100)) * 100 : 0;
        
        // Calculate probability approximation (simplified)
        const distanceToStrike = optionType === 'call' 
            ? (strikePrice - stockPrice) / stockPrice 
            : (stockPrice - strikePrice) / stockPrice;
        const probITM = Math.max(10, Math.min(90, 50 - distanceToStrike * 500));
        
        // Score the option (higher is better)
        let score = 0;
        score += Math.min(50, riskReward * 20); // Up to 50 points for R:R
        score += Math.min(30, percentReturn / 5); // Up to 30 points for % return
        score += probITM * 0.2; // Up to 18 points for probability
        
        recommendations.push({
            strike: strikePrice,
            label: strike.label,
            premium: premium.toFixed(2),
            maxLoss: maxLoss.toFixed(0),
            expectedPnL: expectedPnL.toFixed(0),
            riskReward: riskReward.toFixed(2),
            percentReturn: percentReturn.toFixed(0),
            probITM: probITM.toFixed(0),
            score: score.toFixed(0)
        });
    });
    
    // Sort by score
    recommendations.sort((a, b) => parseFloat(b.score) - parseFloat(a.score));
    
    // Display recommendations
    const container = document.getElementById('aiRecommendations');
    container.innerHTML = '';
    
    recommendations.forEach((rec, idx) => {
        const scoreClass = parseFloat(rec.score) > 60 ? 'high' : parseFloat(rec.score) > 40 ? 'medium' : 'low';
        const pnlClass = parseFloat(rec.expectedPnL) >= 0 ? 'profit' : 'loss';
        
        container.innerHTML += 
            <div class="ai-recommendation ">
                <div class="ai-recommendation-header">
                    <div class="ai-recommendation-title">confluence_agent.yml{rec.strike}  </div>
                    <div class="ai-recommendation-score ">Score: /100</div>
                </div>
                <div class="ai-recommendation-details">
                    <div class="item"><div class="label">Premium</div><div class="value">confluence_agent.yml{rec.premium}</div></div>
                    <div class="item"><div class="label">Max Loss</div><div class="value" style="color:var(--danger);">-confluence_agent.yml{rec.maxLoss}</div></div>
                    <div class="item"><div class="label">Expected P&L</div><div class="value ">confluence_agent.yml{rec.expectedPnL}</div></div>
                    <div class="item"><div class="label">Risk:Reward</div><div class="value">:1</div></div>
                    <div class="item"><div class="label">% Return</div><div class="value ">%</div></div>
                </div>
            </div>
        ;
    });
    
    // AI Analysis Summary
    const best = recommendations[0];
    const direction = optionType === 'call' ? 'bullish' : 'bearish';
    const expectedTarget = optionType === 'call' 
        ? (stockPrice * (1 + expectedMove)).toFixed(2)
        : (stockPrice * (1 - expectedMove)).toFixed(2);
    
    document.getElementById('aiAnalysisText').innerHTML = 
        <strong>ü§ñ AI Analysis Summary:</strong><br><br>
        Based on your  outlook with a % expected move and  DTE:<br><br>
        
        <strong>‚úÖ Recommended Trade:</strong> Buy  at confluence_agent.yml{best.strike} strike<br>
        <strong>üí∞ Cost:</strong> confluence_agent.yml{best.premium} per share (confluence_agent.yml{(parseFloat(best.premium) * 100).toFixed(0)} per contract)<br>
        <strong>üéØ Target Price:</strong> confluence_agent.yml{expectedTarget}<br>
        <strong>üìä Expected Return:</strong> % if target is reached<br>
        <strong>‚öñÔ∏è Risk/Reward:</strong> :1<br><br>
        
        <strong>üí° Strategy Tips:</strong><br>
        <br>
        <br>
        <br>
        <br>
        ‚Ä¢ Consider setting stop-loss at 50% of premium to limit losses
    ;
    
    // Auto-fill the best option into the calculator
    document.getElementById('calcStrikePrice').value = best.strike;
    document.getElementById('calcPremium').value = best.premium;
    calculateOptionsProfit();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(updateCalcPrice, 1000);
});



// ============================================
// MULTI-CHART TECHNICAL ANALYSIS ENGINE
// ============================================

const PHI = 1.618033988749895;  // Golden Ratio
const PHI_INV = 0.618033988749895;  // 1/Phi
const PHI_SQ = 2.618033988749895;  // Phi squared
const SQRT5 = 2.2360679774997896;  // Square root of 5

// Technical Patterns Library
const TECH_PATTERNS = {
    bullish: ['Double Bottom', 'Inv Head & Shoulders', 'Bull Flag', 'Ascending Triangle', 'Cup & Handle', 'Falling Wedge', 'Triple Bottom'],
    bearish: ['Double Top', 'Head & Shoulders', 'Bear Flag', 'Descending Triangle', 'Rising Wedge', 'Triple Top', 'M-Top'],
    neutral: ['Symmetrical Triangle', 'Rectangle', 'Pennant', 'Wedge']
};

const CANDLE_PATTERNS = {
    bullish: ['Hammer', 'Bullish Engulfing', 'Morning Star', 'Three White Soldiers', 'Piercing Line', 'Bullish Harami', 'Dragonfly Doji'],
    bearish: ['Shooting Star', 'Bearish Engulfing', 'Evening Star', 'Three Black Crows', 'Dark Cloud Cover', 'Bearish Harami', 'Gravestone Doji'],
    neutral: ['Doji', 'Spinning Top', 'High Wave']
};

function calculatePivotPoints(high, low, close) {
    const pivot = (high + low + close) / 3;
    const r1 = (2 * pivot) - low;
    const s1 = (2 * pivot) - high;
    const r2 = pivot + (high - low);
    const s2 = pivot - (high - low);
    const r3 = high + 2 * (pivot - low);
    const s3 = low - 2 * (high - pivot);
    return { pivot, r1, r2, r3, s1, s2, s3 };
}

function calculateFibonacci(high, low, trend) {
    const range = high - low;
    if (trend === 'up') {
        return {
            fib0: low,
            fib236: low + range * 0.236,
            fib382: low + range * 0.382,
            fib50: low + range * 0.5,
            fib618: low + range * 0.618,
            fib100: high
        };
    } else {
        return {
            fib0: high,
            fib236: high - range * 0.236,
            fib382: high - range * 0.382,
            fib50: high - range * 0.5,
            fib618: high - range * 0.618,
            fib100: low
        };
    }
}

function calculateDivineProportions(price, atr) {
    return {
        phi: (price * PHI).toFixed(2),
        phiInv: (price * PHI_INV).toFixed(2),
        phiSq: (price / PHI).toFixed(2),
        sqrt5: (price + atr * SQRT5).toFixed(2)
    };
}

function detectPatterns(data, lookback = 20) {
    if (!data || data.length < lookback) return { tech: [], candle: [] };
    
    const recent = data.slice(-lookback);
    const closes = recent.map(d => parseFloat(d.Close || d.close));
    const highs = recent.map(d => parseFloat(d.High || d.high));
    const lows = recent.map(d => parseFloat(d.Low || d.low));
    
    const tech = [];
    const candle = [];
    
    // Simple pattern detection
    const maxHigh = Math.max(...highs);
    const minLow = Math.min(...lows);
    const lastClose = closes[closes.length - 1];
    const prevClose = closes[closes.length - 2];
    const trend = lastClose > closes[0] ? 'bullish' : 'bearish';
    
    // Double bottom detection (simplified)
    const firstHalf = lows.slice(0, 10);
    const secondHalf = lows.slice(10);
    const minFirst = Math.min(...firstHalf);
    const minSecond = Math.min(...secondHalf);
    if (Math.abs(minFirst - minSecond) / minFirst < 0.02 && lastClose > (minFirst + minSecond) / 2 * 1.02) {
        tech.push({ name: 'Double Bottom', type: 'bullish', active: true });
    }
    
    // Higher highs / higher lows
    if (highs[highs.length - 1] > highs[highs.length - 5] && lows[lows.length - 1] > lows[lows.length - 5]) {
        tech.push({ name: 'Higher Highs', type: 'bullish', active: true });
    }
    
    // Lower highs / lower lows
    if (highs[highs.length - 1] < highs[highs.length - 5] && lows[lows.length - 1] < lows[lows.length - 5]) {
        tech.push({ name: 'Lower Lows', type: 'bearish', active: true });
    }
    
    // Bull/Bear flag (simplified)
    if (trend === 'bullish' && (maxHigh - lastClose) / (maxHigh - minLow) < 0.3) {
        tech.push({ name: 'Bull Flag', type: 'bullish', active: true });
    }
    if (trend === 'bearish' && (lastClose - minLow) / (maxHigh - minLow) < 0.3) {
        tech.push({ name: 'Bear Flag', type: 'bearish', active: true });
    }
    
    // Candlestick patterns (last candle)
    const last = recent[recent.length - 1];
    const open = parseFloat(last.Open || last.open_);
    const close = parseFloat(last.Close || last.close);
    const high = parseFloat(last.High || last.high);
    const low = parseFloat(last.Low || last.low);
    const body = Math.abs(close - open);
    const range = high - low;
    const upperWick = high - Math.max(open, close);
    const lowerWick = Math.min(open, close) - low;
    
    // Doji
    if (body / range < 0.1) {
        candle.push({ name: 'Doji', type: 'neutral', active: true });
    }
    
    // Hammer
    if (lowerWick > body * 2 && upperWick < body * 0.5 && close > open) {
        candle.push({ name: 'Hammer', type: 'bullish', active: true });
    }
    
    // Shooting Star
    if (upperWick > body * 2 && lowerWick < body * 0.5 && close < open) {
        candle.push({ name: 'Shooting Star', type: 'bearish', active: true });
    }
    
    // Engulfing
    if (recent.length >= 2) {
        const prev = recent[recent.length - 2];
        const prevOpen = parseFloat(prev.Open || prev.open_);
        const prevClose = parseFloat(prev.Close || prev.close);
        
        if (close > open && prevClose < prevOpen && close > prevOpen && open < prevClose) {
            candle.push({ name: 'Bullish Engulfing', type: 'bullish', active: true });
        }
        if (close < open && prevClose > prevOpen && close < prevOpen && open > prevClose) {
            candle.push({ name: 'Bearish Engulfing', type: 'bearish', active: true });
        }
    }
    
    // Add potential patterns
    if (tech.length < 3) {
        tech.push({ name: 'Ascending Triangle', type: 'bullish', active: false });
    }
    if (candle.length < 2) {
        candle.push({ name: 'Morning Star', type: 'bullish', active: false });
    }
    
    return { tech, candle };
}

function calculateXOSignal(data, boxSize = null) {
    if (!data || data.length < 5) return 'N/A';
    
    const closes = data.slice(-20).map(d => parseFloat(d.Close || d.close));
    const atr = Math.abs(closes[closes.length - 1] - closes[0]) / 20;
    boxSize = boxSize || atr * 0.5;
    
    let columns = [];
    let currentColumn = { type: 'X', values: [closes[0]] };
    
    for (let i = 1; i < closes.length; i++) {
        const diff = closes[i] - currentColumn.values[currentColumn.values.length - 1];
        
        if (currentColumn.type === 'X') {
            if (diff >= boxSize) {
                currentColumn.values.push(closes[i]);
            } else if (diff <= -boxSize * 3) {
                columns.push(currentColumn);
                currentColumn = { type: 'O', values: [closes[i]] };
            }
        } else {
            if (diff <= -boxSize) {
                currentColumn.values.push(closes[i]);
            } else if (diff >= boxSize * 3) {
                columns.push(currentColumn);
                currentColumn = { type: 'X', values: [closes[i]] };
            }
        }
    }
    columns.push(currentColumn);
    
    // Signal based on last column
    const lastCol = columns[columns.length - 1];
    if (lastCol.type === 'X' && lastCol.values.length >= 3) return 'üìà BUY (X column rising)';
    if (lastCol.type === 'O' && lastCol.values.length >= 3) return 'üìâ SELL (O column falling)';
    return '‚è∏Ô∏è HOLD (consolidating)';
}

function updateTimeframeAnalysis(prefix, data, multiplier = 1) {
    if (!data || data.length === 0) return;
    
    const recent = data.slice(-Math.min(50 * multiplier, data.length));
    const last = recent[recent.length - 1];
    
    const high = Math.max(...recent.map(d => parseFloat(d.High || d.high)));
    const low = Math.min(...recent.map(d => parseFloat(d.Low || d.low)));
    const close = parseFloat(last.Close || last.close);
    const atr = parseFloat(last.atr) || (high - low) / 10;
    
    // Pivot Points
    const pivots = calculatePivotPoints(high, low, close);
    document.getElementById(prefix + 'R3').textContent = '$' + pivots.r3.toFixed(2);
    document.getElementById(prefix + 'R2').textContent = '$' + pivots.r2.toFixed(2);
    document.getElementById(prefix + 'R1').textContent = '$' + pivots.r1.toFixed(2);
    document.getElementById(prefix + 'Pivot').textContent = '$' + pivots.pivot.toFixed(2);
    document.getElementById(prefix + 'S1').textContent = '$' + pivots.s1.toFixed(2);
    document.getElementById(prefix + 'S2').textContent = '$' + pivots.s2.toFixed(2);
    document.getElementById(prefix + 'S3').textContent = '$' + pivots.s3.toFixed(2);
    
    // Fibonacci
    const trend = close > (high + low) / 2 ? 'up' : 'down';
    const fibs = calculateFibonacci(high, low, trend);
    document.getElementById(prefix + 'Fib0').textContent = '$' + fibs.fib0.toFixed(2);
    document.getElementById(prefix + 'Fib236').textContent = '$' + fibs.fib236.toFixed(2);
    document.getElementById(prefix + 'Fib382').textContent = '$' + fibs.fib382.toFixed(2);
    document.getElementById(prefix + 'Fib50').textContent = '$' + fibs.fib50.toFixed(2);
    document.getElementById(prefix + 'Fib618').textContent = '$' + fibs.fib618.toFixed(2);
    document.getElementById(prefix + 'Fib100').textContent = '$' + fibs.fib100.toFixed(2);
    
    // Divine Proportions
    const divine = calculateDivineProportions(close, atr);
    document.getElementById(prefix + 'Phi').textContent = '$' + divine.phi;
    document.getElementById(prefix + 'PhiInv').textContent = '$' + divine.phiInv;
    document.getElementById(prefix + 'PhiSq').textContent = '$' + divine.phiSq;
    document.getElementById(prefix + 'Sqrt5').textContent = '$' + divine.sqrt5;
    
    // Patterns
    const patterns = detectPatterns(recent);
    
    const techContainer = document.getElementById(prefix + 'TechPatterns');
    if (techContainer) {
        techContainer.innerHTML = patterns.tech.map(p => 
            <span class="setup-pattern "></span>
        ).join('') || '<span class="setup-pattern inactive">Scanning...</span>';
    }
    
    const candleContainer = document.getElementById(prefix + 'CandlePatterns');
    if (candleContainer) {
        candleContainer.innerHTML = patterns.candle.map(p => 
            <span class="setup-pattern "></span>
        ).join('') || '<span class="setup-pattern inactive">Scanning...</span>';
    }
    
    // X&O Signal
    const xoSignal = calculateXOSignal(recent);
    document.getElementById(prefix + 'XO').textContent = xoSignal;
}

function updateMultiChartAnalysis() {
    if (!currentData || currentData.length === 0) return;
    
    // Simulate different timeframes using daily data
    updateTimeframeAnalysis('m5', currentData.slice(-10), 1);   // 5-min (last 10 bars)
    updateTimeframeAnalysis('m15', currentData.slice(-20), 2);  // 15-min
    updateTimeframeAnalysis('h1', currentData.slice(-50), 3);   // 1-hour
    updateTimeframeAnalysis('d1', currentData.slice(-100), 5);  // Daily
    updateTimeframeAnalysis('w1', currentData, 10);             // Weekly (all data)
}

function refreshMultiCharts() {
    updateMultiChartAnalysis();
    alert('Multi-chart analysis refreshed!');
}

// Initialize on data load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(updateMultiChartAnalysis, 2000);
});

// Auto-refresh every 5 minutes
setInterval(updateMultiChartAnalysis, 300000);


</script>
</body>
</html>
